# 面试题总结（Interview 高频考点）



### 一、Vue 中双向数据绑定的原理

1. **数据变化更新视图：Vue 是通过Object.defineProperty ( ) 来实现数据劫持的，当数据发生变化时，会触发 set 函数，其中可以放置一些更新视图变化的方法在里面，就可以实现数据变化更新视图（发布者---订阅者模式）**

   **注意：发布者就是一些触发事件等，订阅者就是视图层（发布者发布新内容，即更新数据，订阅者就会接收到新内容，视图层发生改变）**

```javascript
// 通过 Object.defineProperty 方法定义对象的属性名和属性值，当调用该对象属性时，会触发get函数，当给该对象属性修改或更新值时，会触发set函数
Object.defineProperty(对象名，对象中的某个属性名，{ get(){ return 属性值 } , set(val){ val是修改或更新该对象属性时的新值 } })
```

2. **视图变化更新数据：通过事件监听即可，当 input 标签里的内容发生变化，会触发 input 事件，然后做一些更改数据的操作，就可以实现视图变化更新数据**



### 二、路由切换的原理

1. **哈希模式切换：由于 URL 地址里的哈希值变化，页面不会刷新，因此可利用 a 标签进行哈希值的改变，当哈希值发生改变，会触发 onhashchange 事件，然后通过 location.hash 获取当前的哈希值并进行判断，在某个区域内渲染对应内容即可**
2. **历史模式切换：循环遍历所有 a 标签，并注册点击事件，然后阻止它的默认跳转行为，通过 history.pushState () 方法实现 URL 地址的切换，该方法第一个参数为null，第二个参数为 ' '，第三个参数为要切换的路径，通常该路径为当前点击的 a 标签的 href 属性值（通过 getAttribute 方法获取），最后可使用 location. Pathname 获取当前切换的路径并进行判断，在某个区域内渲染对应内容即可**



### 三、内存泄漏

**闭包，他是利用 JS 的垃圾回收机制，使用函数嵌套函数的方式，让数据一直存在于内存之中，也就是里层的函数能够访问外层函数的变量，这样我们就可以访问到这个数据，并且可以把里层函数 return 出去，这样在函数外部也可访问该数据，但是这样会造成内存的泄露，数据一直存在，不会被销毁，影响性能，这时候我们就需要手动清空，如把一个闭包影响的变量赋值为 null**

**定时器未销毁，也会造成内存泄漏，需要在页面销毁时清除定时器，或者定时器的第一个参数是字符串而不是回调函数，也会引发内存泄漏**



### 四、性能优化

1. **四个懒加载：请求懒加载、图片懒加载、路由懒加载、JS 文件懒加载**
2. **请求防抖，避免短时间请求次数过多，服务器压力大**
3. **避免频繁操作 DOM，否则会造成回流和重绘的问题**
4. **对请求数据进行缓存（本地存储）**
5. **利用打包优化工具，查看包的体积，将体积较大的包，使用 CDN 加速，而非使用本地资源** 
6. **尽量避免在 HTML 标签中书写 style 属性，以及图片的 src 属性避免为空，否则也会造成性能负担**
7. **使用精灵图进行图标的优化**
8. **将 css 文件和 js 文件放到外部文件中引用**



### 五、BFC

**BFC，又称为 “ 块级格式化上下文 ”，它是一个独立的渲染区域，内部的样式布局和外部没有任何的联系，是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，而 BFC 通常可以达到清除浮动的效果**

**让一个盒子变成 BFC 的盒子，可以设置 “ overflow：除默认值 visible 以外的属性值 ”**

**在特定的条件下，设置 position 为 absolute 或 fixed，也可转换为 BFC 的盒子（但只适用于该盒子需要定位的场景，正常不会使用）**



### 六、防抖和节流

**无论是防抖，还是节流，都是利用延时器 setTimeout 来实现**

**防抖：在一定时间内，多次触发，只会执行最后一次**

**代码实现：每次事件触发时，不要立即执行，而是用延时器 setTimeout 在一秒之后再执行，而在一秒内，这个事件触发了第二次，那么就清除上一个延时器，重新开始计时**



**节流：重复触发的事件，一定时间内只执行一次**

**代码实现：设置一个布尔值的变量 flag 作为节流阀，每次事件触发时，将这个布尔值设为 false，这个 flag 控制事件触发后是否执行，同时设置一个延时器，一定时间后将 flag 设为 true，这样就可以控制在短时间内，flag 未被置为 true 时，不可再次执行**



### 七、EventLoop 事件循环

**js 是一个单线程的执行机制，为了克服单线程遇到一个执行时间过长的事件就卡住的缺点，js 引入了异步，这样同步任务和异步任务的执行机制就叫做 EventLoop 事件循环**

**首先，js是从上到下依次执行的（同步任务），遇到异步任务（如：定时器，请求，promise）就丢到异步执行栈中，等同步任务全部执行完后，就打开异步任务执行栈（此时异步任务的执行顺序已经确定），从上到下执行，遇到异步任务附属的微任务（如：promise上的语法，.then，await），就先执行微任务，等全部执行完之后，再去任务列表里查找有没有需要执行的同步任务和异步任务，有就执行，如此循环往复**



### 八、原型链

**当通过实例化对象来访问某个方法时，首先会查找通过 this 定义的方法，如果没查找到，该实例化对象有个隐藏的 __ proto __ 属性（又称对象原型，简称 __ proto __ 原型），该对象原型指向构造函数的原型对象（即：构造函数名 . prototype），所以便会查找这个原型对象里的方法，如果该构造函数的原型对象里也没有查找到这个方法，由于构造函数的原型对象也是一个对象，里面同样有 __ proto __ 原型，且指向 Object 里的原型对象，因此会顺着 Object 里的原型对象查找，如果还没有，同理，Object 里也有个 __ proto __ 原型，但是它指向的是 null，这个查找过程，被称为原型链查找**

