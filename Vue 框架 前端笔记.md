# Vue 框架 前端笔记



### webpack的使用

**webpack（模块打包工具）：一个第三方模块包，用于分析，压缩并打包代码**

##### （一）使用步骤

1. **初始化包环境（生成 package.json 文件)：npm init**
2. **安装依赖包（注意是以开发依赖安装）：npm i webpack webpack-cli -D**
3. **在 package.json 文件中的 scripts 选项中配置自定义命令："scripts": { "自定义命令如 w": "webpack" }**
4. **新建 src 文件夹，生成 index.js 文件（默认 src 文件夹下的 index.js 为入口文件，可通过修改配置文件，更改入口文件路径及文件名）**
5. **使用 npm run w 执行打包命令（默认打包到 dist 文件夹下，可通过修改配置文件，更改出口文件路径及文件名）**

##### （二）修改配置文件

**与 src 文件夹同级，新建 webpack.config.js，在 webpack.config.js 中写入以下代码：**

**注意：使用如下配置前，先安装以下包（注意是以开发依赖安装）**

1. **使用加载器让 webpack 可以处理 css 文件：npm i css-loader style-loader -D**
2. **使用加载器让 webpack 可以处理 less 文件：npm i less less-loader -D**
3. **使用自动生成 html 的插件（配置文件中需导入）：npm i html-webpack-plugin  -D**
4. **使用降级处理高版本 js 语法的插件：npm i babel-loader @babel/core @babel/preset-env -D**

```javascript
// 引入路径模块
const path = require("path");
// 引入自动生成 html 的插件
const HtmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
  entry: "./src/main.js", // 可更改入口文件路径及文件名
  output: {
    path: path.join(__dirname, "dist"), // 可更改出口文件夹路径及文件夹名
    filename: "bundle.js", // 可更改出口文件名
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: "./public/index.html", // 以此路径下的html模板为基准，生成打包压缩后的html文件放在dist文件夹内
      inject: "body", //始终让script标签在body的下面
    }),
  ],
  module: {
    rules: [// loader(加载器)的规则
        // css加载器
      {
        test: /\.css$/, // 匹配所有的css文件
        // 顺序不能颠倒，必须从右往左，先用 css-loader 让webpack能够识别 css 文件的内容并打包，再用 style-loader 将样式, 把css插入到dom中
        use: ["style-loader", "css-loader"],
      },
        //less加载器
      {
        test: /\.less$/,
        // 使用less-loader, 让webpack处理less文件, 内置还会用less翻译less代码成css内容
        use: ["style-loader", "css-loader", "less-loader"],
      },
        // webpack5内置加载图片功能，直接配置规则即可
      {
        test: /\.(png|jpg|gif|jpeg)$/i,
        type: "asset",
      },
        // webpack5内置加载字体图标功能，直接配置规则即可
      {
        test: /\.(eot|svg|ttf|woff|woff2)$/,
        type: "asset/resource",
        generator: {
          filename: "font/[name].[hash:6][ext]",
        },
      },
        //处理高版本js语法
      {
        test: /\.js$/,
        exclude: /(node_modules|bower_components)/,
        use: {
          loader: "babel-loader",
          options: {
            presets: ["@babel/preset-env"], // 预设:转码规则(用babel开发环境本来预设的)
          },
        },
      },
    ],
  },
};
```

##### （三）webpack 开发服务器

**又称为本地热更新开发服务器，使得第一次打包后，当启动了开发服务器，每次更新代码，会自动打包在内存中（非打包在 dist 文件夹中），浏览器实时更新**

1. **下载依赖包：npm i webpack-dev-server -D**
2. **在 package.json 文件中的 scripts 选项中配置自定义命令："scripts": { "serve": "webpack serve" }**
3. **启动开发服务器：npm run serve**

**解决 mode 问题：在 webpack.config.js 配置文件中的 module.exports 中新增一行代码，即 module.exports = { mode: "development" , 其余代码 }**

**注意：修改启动端口需要在 webpack.config.js 配置文件中的 module.exports 中新增如下代码：**

```javascript
module.exports = {
  devServer: {
    port: 3000, //配置服务器端口号
    open: true, //浏览器自动打开
  },
    //其余代码
};
```



### Vue 框架

**Vue 是一个JavaScript渐进式框架（需要哪个组件就使用哪个组件），采取了 MVVM 设计模式，推荐使用工程化开发 Vue**

**补充知识：在 Vue 中，@ 是 src 的绝对路径，通常在引入src下的文件时，使用 " @/src下文件的路径 "，但在 css 中使用 @ 时，必须在 @ 前面加上 ~（波浪线）**

**面试题：谈谈对 MVVM 设计模式的理解？答：M，数据层，就是 data 函数 return 出去的数据；V，视图层，就是 template 里的 HTML 标签；VM，视图模型，就是 Vue 对象实例，MVVM 设计模式，可以使得数据驱动视图，即数据层发生改变，视图层也发生改变，当使用 v-model 实现数据的双向绑定，就能反过来让视图层改变，数据层也发生改变**

**面试题：为什么数据要写在 data 函数里并被 return 出去？而不是写在 data 对象里？答：不使用 return 包裹的数据，数据会在项目的全局中可见，组件复用的时候，访问的都是一个 data 数据，会造成变量污染，使用 data 函数 return 一个新的对象，组件复用的时候，组件各自访问各自的局部数据，没有变量污染**



#### 一、Vue 脚手架的安装

**脚手架：@vue/cli 是 Vue 官方提供的一个全局模块包，用于创建脚手架项目，脚手架是一个工作平台，无需配置 webpack，开箱即用**

**每台设备全局安装一次 @vue/cli 即可：npm i @vue/cli -g**

**验证是否安装成功：vue -V**

**注意：安装完后会在计算机中配置全局命令（vue命令），如果提示找不到该命令，配置环境变量即可**

**卸载 Vue 脚手架：npm uninstall @vue/cli -g**



#### 二、Vue 创建脚手架项目及基本配置和使用

##### （一）创建脚手架项目

**创建项目（建议使用 cmd 终端）：vue create 项目名称**

**注意：项目名称不能含有大写字母、中文和特殊符号**

**启动内置的 webpack 本地热更新开发服务器（无需额外配置）：npm run serve**

**注意：使用 Vue-cli 脚手架创建项目时，提供的默认选项 2.0 和 3.0，都只包含 eslint 和 babel，缺少 less 或 sass 依赖及对应 loader 解析器，需要额外下载**

```bash
// less 预编译语言需要下载指定版本
yarn add less@3.0.4 less-loader@5.0.0 -D

// sass 预编译语言下载最新版本即可
yarn add sass sass-loader -D
```

**注意：实际开发中通常使用自定义选项对项目进行创建，空格选中 CSS Pre-processors，可选择使用 less 或 sass 语法，无需额外下载**



##### （二）基本配置

**在 src 同级处新建 vue.config.js 文件，填入以下配置，并重启开发服务器：**

**注意区分：Vue 中的配置文件与原生 webpack 不一样，项目中没有 webpack.config.js 文件，因为 Vue 脚手架项目用的是 vue.config.js 文件，新建配置文件时，必须使用该名**

```javascript
// vue 脚手架项目默认的配置文件为 vue.config.js
module.exports = {
  devServer: {
    port: 3000, // 配置服务器端口号
    open: true, // 浏览器自动打开
  },
  lintOnSave: false, // 关闭 eslint 项目执行检查，此处关闭并不是指代码不会 eslint 校验，而是 eslint 校验即便报红错误，也不影响项目正常执行
};
```

**补充（一般不用）：在 package.json 文件中，将 scripts 配置项里的 "serve": "vue-cli-service serve" 修改为 "serve": "vue-cli-service serve --hot --open --host 127.0.0.1"，由于设置了 --open，在启动服务器的时候，会自动打开浏览器，无需在 vue.config.js 文件中额外配置 open: true**



##### （三）清理 Vue 欢迎界面

**assets 和 components 下的文件全部删除，保留 App.vue 文件，但删除里面内容，输入 < vue > 智能提示生成模板即可**

**注意：.vue 结尾的文件被称为单文件，拥有独立作用域，可以避免变量冲突，template 标签内只能存在一个根标签，其余标签需要书写在这个根标签内，一般而言，这个根标签是 div 标签**

**补充：Vue 推荐使用 .vue 单文件，且要求尽可能不操作 DOM，转变思想（数据驱动视图）**



##### （四）vue-cli 进阶配置

**vue-cli 脚手架创建项目后，会包含一个对象，即 process.env，在项目根级别有两个配置文件，分别是 .env.development 和 .env.production 文件，里面的内容是键值对（键名 = 键值）的形式，且末尾不能有分号，当处于开发环境，会加载 .env.development 里的内容，当处于生产环境，会加载 .env.production 里的内容，因此，在任意文件中，可通过 ” process.env.键名 “ 的形式获取相对应被加载配置文件里键的值**

**尤其注意：官方规定，键的取名，必须以 VUE_APP_ 开头，否则无法访问**

**尤其注意：项目根级别如果存在一个 .env 文件，其中的变量会在任意环境生效（被访问到）如果特定的环境文件（.env.development 和 .env.production 文件）有相同的变量，则会从特定的环境文件中读取（优先级最高）**

**尤其注意：process.env 有一个自带的 Node 环境变量（NODE_ENV），使用 process.env.NODE_ENV 可以访问到该值，该值依赖于项目的启动命令，自动切换，当处于开发环境时，保存的是 “ development ”，当处于生产环境时，保存的是 ” production “，当处于测试环境时，保存的是 “ test ”**



#### 三、Vue 基础语法

##### （一）差值表达式

**语法：{{ vue变量 或 表达式 }}**

**注意：差值表达式一般搭配标签使用，即标签内部使用差值表达式，可以解析 vue变量，渲染数据（把值显示在标签夹着的地方）**

**注意：if 语句不是表达式，在双重花括号中，必须使用三目运算表达式作为条件判断**

**易混淆：插值表达式用于标签内部，v-bind 用于标签的原生属性或者自定义属性，注意区分**

**注意：插值表达式等同于 v-text，二者任选其一，尤其注意，如果需要渲染出标签，就不能使用插值表达式，而是使用 v-html 替换**



##### （二）vue变量、函数方法的书写位置

**vue变量都放在 export default 中 data 函数下 return 的对象里面，函数方法都放在 export default 中的 methods 里面：**

```javascript
export default {
  data() {
    return {
        // 固定写法，存放vue变量
    };
  },
  methods: {
      // 固定写法，存放函数方法
      // 尤其注意，这里的方法如果需要访问data里的 vue变量，需要加 this
  },
};
```

**尤其注意（非常重要）：当某些情况，函数嵌套较深，this 的指向发生变化，无法正常访问数据或者方法，可以在能正常访问到 this 的地方，通过一个新的变量，保存当前 this（ let _this = this ），最后通过 ” _this.数据或者方法 “ 进行访问即可**



##### （三）原生属性使用变量

**某些原生属性，如 href、src 属性，它们的属性值使用 vue变量，需要采取如下方式：**

1. **v-bind：原生属性名 = " vue变量 "**

2. **：原生属性名 = " vue变量 "（简单方式）**

   **尤其注意：在 template 模板中，如 img 标签的 src 属性，可以直接书写图片路径，但唯独在 script标签（js 文件）中不能直接书写图片路径，因为工程化开发，默认把 js 文件（script 同理）当作一个模块，不能直接访问本地资源，必须通过模块化语法，导入具体的资源文件，通常将导入的文件保存在 vue变量中，如果将图片路径单纯的保存在 vue变量中使用，保存的则是字符串**
   
   ```javascript
   // 第一种方式
   import 接收名 from "资源路径"
   vue变量: 接受名
   
   // 第二种方式
   vue变量: require('资源路径')
   ```



##### （四）事件绑定

1. **v-on : 事件类型 = " methods 里函数 或者 简单代码块 "** 
2. **@事件类型 = " methods 里函数 或者 简单代码块 "（简单方式）**

**注意：无传参，直接写函数名即可，如果有传参，需要写括号并填入实参**

**尤其注意：很多情况下，事件绑定会和 v-for 方法搭配使用，v-for 方法中的 item 和 index 会被当作实参传到事件处理函数中**

**尤其注意：v-for 循环绑定多个事件，共用一个事件处理函数，互不影响（原因：当前标签只触发当前事件）**



##### （五）Vue 方式绑定事件，获取事件对象 event 的方式

1. **methods 里的事件处理函数如果不需要传参：函数名（e） { e.preventDefault ( ) }**

   **绑定事件时：@事件类型 = " 函数名 "**

2. **methods 里的事件处理函数如果需要传参：函数名（形参，e） { e.preventDefault ( ) }**

   **绑定事件时：@事件类型 = " 函数名（实参，$event） "**

**事件对象 event（简写 e）中，有两个属性最常用，且容易混淆，e.currentTarget，获取的是当前事件绑定的元素（自己），e.target，获取的是当前事件绑定的元素中被触发的具体元素（子元素或者自己），由于事件冒泡，当点击子元素，会冒泡到父元素，执行父元素的事件函数，父元素的事件函数中，e.target 获取到的其实是子元素，而不是父元素，此处切忌混淆**

**通过事件对象，也可获取到当前元素上的自定义属性**

1. **vue 中给元素绑定自定义属性：`:data-自定义属性名称 = " 属性值 "`**
2. **e.currentTarget 或 e.target 里有一个 dataset 属性，其中包含了当前元素所有的自定义属性**

**滚动条事件：在 vue 中，@scroll 是滚动条事件，给某个元素绑定（要求该元素必须具有滚动条，可利用 overflow-y: auto + 固定高度，使该元素具有滚动条），监听的是该元素内部的滚动条事件（可获取该元素内部的滚动数据），e.currentTarget.scrollTop 获取的便是该元素里面内容整体向上滚动出去的距离**



##### （六）事件修饰符

**语法：@事件类型 . 修饰符 = " 函数名 "**

**修饰符列表：**

1. **阻止冒泡：@事件类型 . stop = " 函数名 "**

2. **阻止默认行为：@事件类型 . prevent = " 函数名 "**

3. **只触发一次事件处理函数：@事件类型 . once = " 函数名 "**

4. **监听回车或者退出：@键盘事件 . enter（或者 esc） = " 函数名 "**

   **尤其注意：当使用某些组件库时，组件库封装的非原生标签，在绑定事件时，可以使用修饰符 .native 监听该标签的原生事件**



##### （七）v-model 表单双向绑定

**给某个表单标签（如 input）添加一个 v-model = " vue变量 "，就可以让表单标签的 value 属性值和 export default 中 data 函数下 return 的对象里面的 vue变量实现双向绑定**

**注意：下拉菜单要给 select 标签绑定 v-model = " vue变量 "**

**尤其注意：遇到复选框，且是多个复选框，每个复选框都要绑定同一个 vue变量（v-model = " vue变量 "），并且该 vue变量的数据类型必须是数组类型（vue变量初始化成数组，即 vue变量：[ ]），才能关联 value 属性（每选中一个复选框，都会把当前复选框的 value 值追加到这个 vue 变量中），如果只有一个复选框，通常该复选框绑定的 vue变量是非数组，关联的则是 checked 选中状态属性（true 或 false）**

**尤其注意：实现双向绑定后，从表单同步到 vue变量里的数字，是字符串类型，可使用修饰符（. number）转换**

**尤其注意：v-model 可以给自己封装的组件使用（代替父传子），达到传参的作用，组件内部使用 props 接收，且名字必须为 value，需要注意的是，在 vue2 中不能重命名，也就是说组件内部 props 接收的名字必须为 value（vue3 中是 modelValue，可以重命名），如需达到双向数据绑定的效果，则需要使用子传父更新数据，但无需在父组件中的子组件标签名上接收自定义事件，而是在子组件内部直接使用 this.$emit ( 'input' , 更新的值 )**

**语法：v-model . 修饰符 = " vue变量 "**

**v-model 修饰符列表：**

1. **转换为数字型：v-model . number = " vue变量 "**
2. **去除首尾空格：v-model . trim = " vue变量 "**
3. **失去焦点内容改变时：v-model . lazy = " vue变量 "**



##### （八）v-html 修改标签里的内容

**给标签添加：v-html = " vue变量 "**

**尤其注意：v-html 可以让标签内部渲染出 html 标签，该 vue变量存储的是字符串，使用时会自动解析为 html 代码，并且使用该方法会覆盖差值表达式**

**尤其注意：v-html 不能使用过滤器，可以定义一个过滤的方法（函数）给 vue变量使用（用于改造原始数据）：v-html = " 过滤方法名（vue变量）"**

**尤其注意：既然选择使用 v-html，主要目的便是为了渲染标签，而渲染标签的同时又使用过滤方法，大多情况是为了给原始数据嵌套一层 html 标签，常搭配 replace 方法进行替换，如关键词高亮显示，而关键词又不唯一（动态），因此常采取 replace 的正则替换方法**



##### （九）显示与隐藏

1. **v-show = " vue变量 "**

   **注意：该 vue变量存储的是布尔值，根据布尔值决定显示（true）或隐藏（false），且隐藏方式为 display：none，常用于频繁切换状态**

2. **v-if = " vue变量 "**

   **注意：该方法同上，但隐藏方式为直接移除**

**补充：true 和 false 的反复切换（取反思路：每次点击，都会取反，即 this.flag = ! this.flag）**

**注意：v-if 常与 v-else 搭配使用，两者必须紧挨在一起，常用于根据判断条件只显示其中一个，如：点击按钮变成输入框，回车输入后再次变回按钮**

**尤其注意：业务场景要求，三者只显示一个，如搜索功能（关键字联想、历史记录、搜索结果），使用 v-if + v-else-if + v-else 即可实现**



##### （十）循环遍历数组、对象并实时渲染数据到页面

**v-for 方法，可以循环遍历数据，并且数据变化的同时，会触发 v-for 的更新，使得页面被实时渲染**

**v-for 使用步骤：**

1. **想要循环某个标签，就给这个标签添加 v-for = "（item，index） in 需要循环的数据 "**

2. **然后在这个标签内部根据 item 写上具体的渲染结构样式**

   **注意：item 是遍历数据的每一项（当前项），index 是索引值（下标），通常会把这个索引值当作某个事件的实参，由事件处理函数做相应处理**
   
   **注意：循环生成标签的原因在于，不确定有几条数据，如果后期增加了数据，循环生成标签就可以一劳永逸**



##### （十一）动态类名和动态样式（class 和 style）

**都是基于 v-bind 实现**

1. **设置动态 class（尤其注意，正常类名和 动态class 互不影响）**

   **：class = " { 类名：vue变量（注意存放的是布尔值） } "**

   **style标签中正常写类名样式，然后通过 vue变量的变化来控制是否使用该类名（控制单个类名的使用）**

   **补充：除了布尔值的 vue变量，此处也可以是条件表达式，来判断是否为 true，用来控制是否使用该类名（ ：class = " { 类名：条件表达式） } " ）**

   

   **以上写法仅限单个类名，当需要根据不同情况切换不同类名，则必须使用三元表达式，但是，使用三元表达式需要换另一种写法（适用于多个类名的切换）**

   **：class = " [ 条件 ? ' 类名1 ' : ' 类名2 ' ]"**

   **补充：中括号也可以省略（ ：class = " 条件 ? ' 类名1 ' : ' 类名2 ' " ）**

2. **设置动态 style**

   **：style = " { css属性名：vue变量（注意存放的是 css 属性值） } "**

   **注意：这里的 vue变量，存放的必须是字符串，且可以使用三元表达式**
   
   
   
   **以上写法仅限固定的 css 属性名的属性值切换，当需要根据不同情况，进行复杂的样式变化时，则采取以下写法**
   
   **：style = " 计算属性名 "**
   
   **计算属性名（）{ 根据不同情况 return { css属性名：' 属性值 '（非变量，而是固定的值，且需要加引号） } }**



##### （十二）过滤器的使用

**前提条件：过滤器只能使用在差值表达式和 v-bind 动态属性里（注意：v-html 里面不能使用过滤器）**

1. **全局注册**

   **在 main.js 文件中注册，就可以在任意 .vue 文件（强调：注意是组件）中直接使用**

   **语法：Vue . filter（" 自定义过滤器名称 "，（val） = > { 处理 val 的程序；return 经过处理后的结果 }）**

   **使用：需要被过滤的vue变量 | 自定义过滤器名称**

**尤其注意：在任意 js 文件中，书写了 Vue 进行挂载（如：挂载 filter），都没有真正执行挂载的代码，因为该 js 文件和项目工程没有任何关联，所以必须在 main.js 中引入该文件，才相当于全局注册**

2. **局部注册**

   **在 .vue 文件中 export default 下的 filters 配置项中定义过滤器**

   **语法：自定义过滤器名称（val）{ 处理代码的程序；return 经过处理后的结果 }**

   **使用：需要被过滤的vue变量 | 自定义过滤器名称**

**注意：val 接收的是需要被过滤的 vue变量（给哪个 vue变量使用过滤器，val 接收的就是那个 vue变量）**

**多个过滤器使用：需要被过滤的vue变量 | 自定义过滤器名称 1 | 自定义过滤器名称 2**

**注意：过滤器在使用时，只写名称即可，如果有额外传参，需加括号，在定义过滤器时，val 的后面增加一个形参**

3. **过滤器的进阶用法**

   **（Ⅰ）在 src 下新建 filters 文件夹，并在该文件夹下新建 index.js 文件，正常书写过滤方法并按需导出即可（普通函数的形式，形参为需要过滤的值）**

   **（Ⅱ）在 main.js 文件中，使用 import * as filters from '@/filters' 引入所有的方法，并以对象形式保存在 filters 中**

   ```javascript
   // filters 内部形式如下：
   filters:{
       过滤方法名1: function (val) {
             处理 val 的程序;
             return 经过处理后的结果
         },
       过滤方法名2: function (val) {
             处理 val 的程序;
             return 经过处理后的结果
         }
   }
   ```

   **（Ⅲ）在 main.js 文件中，使用如下方法遍历所有的方法，进行过滤器的全局注册**

   ```javascript
   // 遍历 filter 的所有键（属性名），以键作为过滤器的名字，以值（属性名对应的方法）作为过滤器的方法
   Object.keys(filters).forEach(key => {
       Vue.filter(key , filters[key])
   })
   ```

**注意：自定义指令虽然也可使用此类方法进行全局注册，但自定义指令常见使用方式是，利用 Vue.use 执行某个对象里的 install 方法，来进行全局注册，详细参考《组件的全局注册及进阶用法》**



##### （十三）计算属性

**计算属性，指的是依赖 data 配置项里的 vue变量而执行程序，随着 vue变量的变化而变化**

**计算属性（可实时更新和计算的变量），放在 export default 下的 computed 配置项中：**

1. **低阶语法（格式类似于 methods 下的函数）：**

   **计算属性名（）{ 处理程序；return 处理结果 }**

2. **完整语法（当计算属性搭配 v-model 使用）：**

   **注意：由于 v-model 绑定计算属性，表单只能获取计算属性的值，但不能给计算属性赋值，此时采取完整语法**

   ```javascript
     computed: {
       计算属性名: {
           //对计算属性进行赋值时（在复选框中是通过勾选赋值true或者false，其余情况：“计算属性=某个值” 赋值），调用set函数
         	set(val) {
               // val是对计算属性赋值时，传递过来的参数（在复选框中是true或者false，在其余情况是某个值）
               利用val执行某些操作
           },
           //当别的地方需要获取计算属性时，调用get函数
         	get() {
           return 处理结果（值）;
         	},
       },
     },
   ```

**计算属性与函数的区别：计算属性自带缓存，多次调用会从缓存取值，只有发生变化后，才会重新执行，但是methods下的函数多次调用时，会每次都执行**

**尤其注意：计算属性里面只能书写同步代码，不能书写异步代码**

**特别注意（强调）：如果计算属性中 return 的值是通过条件判断而来，需要考虑是否存在某些情况没有走分支，导致 return null 产生报错**

**深入理解：“ 计算属性 = 某个值 ” 表面上是给计算属性赋值，实际上只是把 “ 某个值 ” 传递到该计算属性的 set 函数中，作为参数使用，val 就是 “ 某个值 ”**

**何时使用 v-model 绑定计算属性：**

**一般情况，v-model 都是绑定正常的变量，当绑定的变量，无法正常进行获取和修改时（即获取的值和修改的值与预期达到的值不一样时），就可以通过将 v-model 绑定一个计算属性，通过该计算属性的 get 方法获取正确的值（该值与原本的变量有关，通过改造得来），通过该计算属性的 set 方法给原本的变量修改值（通常应用于 v-model 双向绑定的表单数据，与请求参数真正需要提交的数据不一致时，或者绑定的是 vuex 中的数据时）**



##### （十四）侦听器（多应用于本地存储数据缓存，搜索框输入等）

**侦听器是频繁触发的，可以实时侦听某个变量值的改变**

**侦听器放在 export default 下的 watch 配置项中：**

1. **低阶语法（适用于侦听简单类型数据）：**

   ```javascript
   // 此种形式为 ES6 写法
   watch: {
       被侦听的计算属性名或vue变量名（newVal，oldVal） {
           此处为处理程序
       },
   },
   // 原生写法剖析：本质就是，在watch对象里，被侦听的变量，作为属性名，属性值是个函数（即对象方法）
   watch: {
       被侦听的计算属性名或vue变量名: function（newVal，oldVal） {
           此处为处理程序
       },
       // 如果侦听的是对象里面的某个属性，必须使用引号包裹该变量（原因：obj.xxx.xxx 是取值，并不是属性名，写引号形式可以解析成属性名）
       "obj.xxx.xxx": function（newVal，oldVal） {
           此处为处理程序
       },
   },
   ```

   **注意：低阶语法不能深度侦听（即 不能侦听对象里的每一项）**

2. **完整语法（可深度侦听，侦听的是整个对象，而非侦听对象里面的某个属性，也就是说被侦听的 vue 变量是对象形式）：**

   ```javascript
   watch: {
       被侦听的计算属性名或vue变量名: {
           handler (newVal,oldVal) {
               // 若是数组，当数组变化时，可以使用该方法拿到变化的值
               const addedValues = newVal.filter(item => !oldVal.includes(item));
               const removedValues = oldVal.filter(item => !newVal.includes(item));
   
               // 数据发生增加变化
               if (addedValues.length > 0) {
                   console.log('数据变化后，增加的数据集合:', addedValues);
               }
               // 数据发生减少变化
               if (removedValues.length > 0) {
                   console.log('数据变化后，减少的数据集合:', removedValues);
               }
           },
           deep: true, // 开启深度侦听，可侦听复杂类型数据内的变化
           immediate: true // 立即执行（页面一刷新就执行）
       }
   }
   ```

**尤其注意：被侦听的计算属性名或vue变量名，一定要和真正的计算属性名和 vue变量名保持一致，表示正在侦听当前数据，且不需要加 this**

**尤其强调：watch 侦听的变量名不需要加 this**

**尤其注意：当侦听的时复杂类型数据（object 引用类型：数组或者对象），使用 “ 深度侦听 ” ；当遇到某个组件是刚创建出来的情况，使用 “ 立即执行 ”** 

**深入理解 watch 频繁触发的部分：handler（）{ 此处内容会频繁触发 } 是 es6 的新写法，原生写法如下**

```javascript
      handler: function (newVal,oldVal) {
          实际上频繁触发的是整个函数部分（即 handler 冒号后面的内容：function (newVal,oldVal) {}）
      },
```

**因此在使用 lodash 工具库中的 debounce 防抖函数时，该 debounce 防抖函数要求包裹的是需要防抖、频繁触发的函数，即冒号后面的整个内容都需要进行防抖，如果 debounce 防抖函数是写在 function (newVal,oldVal) { } 的里面，由于 function (newVal,oldVal) { } 整个部分（包括里面的内容）都是频繁触发的，就会造成里面的 debounce 防抖函数被多次调用，生成多个作用域，明显不合理**

**简单剖析：debounce 要求包裹频繁触发的部分，而不是被频繁触发的部分包裹**



#### 四、解决无法触发 v-for 更新的问题

##### （一）能触发 v-for 更新 的情况

**数组变更方法：push、pop、shift、unshift、splice、sort、reverse，由于这些方法会从根本上改变原数组，因此能触发 Vue 中的 v-for 更新（即：实时渲染数据到页面）**



##### （二）不能触发 v-for 更新 的情况

1. **数组非变更方法：slice、map、filter、concat，由于这些方法返回的是一个新数组，因此不能触发 Vue 中的 v-for 更新，可采用覆盖数组解决（拿返回的新数组，直接替换旧数组）**
2. **单独给数组中的某一个元素重新赋值或修改数组的长度，不会触发 Vue 中的 v-for 更新，必须使用 this . $set（数组名，更新的位置索引，要更新的值）方法给某个数组元素赋值，即可对视图进行更新**
3. **给对象动态添加属性并赋值，或者删除对象中的某一个属性，也不会触发 Vue 中的 v-for 更新，可使用 this . $set（对象名，属性名，要更新的值）方法给某个对象元素赋值，也可在操作数据结束后使用 this.$forceUpdate（）方法，对视图强制更新，该方法同样适用于数组操作造成的不更新问题**

**尤其重要：在 Vue 中，很少会操作对象中数据的删除或增加，只有在需要缓存多份数据（使用不同的属性名保留多组数据）的情况下，会操作对象，但由于直接操作对象的删除和增加，不能触发响应式，因此常使用解构、拼接的方法，给对象整体重新赋值**

**尤其注意：能触发 v-for 更新 的 JS 原生方法中，必须只能使用数组方法，如果数组方法和字符串方法结合使用，则必须通过覆盖替换来解决**



#### 五、v-for 更新原理及 key 的使用

##### （一）v-for 更新原理

**在 template 模板标签里的内容，需要被 Vue 解析成一套虚拟的 DOM 结构，再转成真实的DOM，虚拟DOM本质是保存 DOM 关键信息的对象，这样在渲染过程中，避免了重复遍历**

**v-for 更新是通过虚拟DOM的新旧对比，在内存中对比变化部分，尝试复用标签就地更新内容（diff 算法，同级较，相同标签，只更新属性），比原生 js 操作 DOM（删除并重新渲染）性能更高**

**diff 算法流程：同级比较，当根元素发生变化时，会删除当前所有虚拟DOM，重新建立一套新的虚拟DOM，当子元素内容发生改变时，就地更新，复用当前标签，只更新属性，如果多生成一个标签，就更新一个新的虚拟DOM节点，如果有 key，就根据 key 值进行比较，但 key 值相同，仍然会就地更新，但如果根据 id 设置 key，同级比较的过程中，会直接生成一个新的虚拟DOM节点，其它标签不会变化，渲染性能更高效**

**简单记忆：无 key，就地更新，有 key，按照 key 比较，有 key 无 id，就地更新，有 key 有 id，性能最高**



##### （二）key 的使用

1. **给每个数据换成对象，准备 id，把 id 值作为 key，可以配合虚拟DOM，使 v-for 更新的性能达到最高**

2. **与 v-for 搭配使用，给标签加上如下代码：**

   **：key = " item . id "**

   **注意：key 的使用，基于 v-bind 实现，所以要加冒号，key 的值是 vue变量，一般是对象形式的数据中 id 值，唯一不重复即可**



#### 六、Vue 实现 "点击高亮，再次点击恢复"

##### （一）单个按钮

**通常准备一个 vue变量 flag，再准备一个高亮类名，利用 flag 值的变化决定是否使用该类名，给按钮绑定事件，当点击该按钮，flag 的值取反**

##### （二）多个按钮（多个按钮可同时高亮）

1. **以对象形式存放每个按钮的数据：btns : [ { name: "按钮一", flag: false } , { name: "按钮二", flag: false } , { name: "按钮三", flag: false } ]**
2. **利用 v-for 方法循环生成三个按钮，并使用 item 渲染按钮的内部结构，准备一个类名，利用 item.flag 值的变化决定是否使用该类名**
3. **给循环生成的按钮添加点击事件，并把 item 当作实参传入事件处理函数**
4. **当点击当前按钮时，给当前 item.flag 取反**



#### 七、Vue 实现 Tab 栏效果

##### （一）固定写死的多个按钮

1. **准备一个自定义变量，初始值为 1，给每个按钮添加点击事件，当点击按钮时，将自定义变量更改为当前的次序（点击第 n 个按钮，自定义变量改为 n）**
2. **给每个按钮添加动态类名，动态类名是否生效的判断条件为：自定义变量存放的次序是否等于当前次序**

##### （二）循环生成的多个按钮

1. **准备一个自定义变量，初始值为0，给循环生成的按钮绑定点击事件，当点击按钮时，将自定义变量更改为当前索引**
2. **准备一个动态类名，动态类名是否生效的判断条件为：当前索引是否等于自定义变量存放的索引**



#### 八、组件相关

##### （一）组件的概念

**每一个单文件（.vue 文件），被称为组件，App.vue 文件被称为根组件，其余组件放在 components 文件夹下，被称为子组件，子组件分别负责页面的各个模块，然后被根组件（App.vue）引入，构成完整的页面**

**注意：在 Vue 中，组件的 style 标签如果添加了 scoped 属性，该组件内的样式，只针对当前组件有效，原理是增加了一个哈希值，使类名变成了交集选择器**

**尤其注意：如果不添加 scoped 属性，只需要给根标签一个类名，样式在该类名下书写（通过后代选择器），就可以达到同样的效果，因此某些情况可以不写 scoped 属性，scoped 等同于给根标签加一个类名，二者任选其一**



##### （二）组件封装及局部注册

1. **创建组件：在 components 文件夹下，新建 .vue 文件，注意，每个组件内部要有完整的模板结构（利用 < vue > 快速生成即可），写入可复用的代码**

2. **引入组件：在任意单文件中（.vue 文件），通过 import 引入创建好的组件**

   ```javascript
   import 组件名（一般和组件文件名称保持一致，且首字母大写） from “组件所在路径”
   ```

3. **注册组件：在根组件里 export default 的 components 配置项中，导出前面引入的子组件，供 template 标签内部使用**

   ```javascript
   export default {
       components : {
           // 原始写法
           组件标签名：组件名
           // 注意：一般情况，组件标签名会和组件名保持一致，对象中存在简化写法，因此直接写组件名即可
           组件名（简单写法：组件标签名就是组件名）
       }
   }
   ```

4. **使用标签：在 template 中书写 < 组件标签名 > </ 组件标签名 > 即可**

**尤其重要：如果组件标签名，采取大驼峰命名法（如 BoxName），在 template 中使用标签，可转换为 < box-name > </ box-name > 的形式**

**尤其注意（尤其重要！！！）：封装的组件，大部分情况只承担循环和组件通信的职责，直接给组件绑定事件无效，一般事件都是在组件内部进行绑定触发**



##### （三）组件的全局注册及进阶用法

**当一个组件被多个页面重复使用，为了避免多次局部注册该组件，可将该组件进行全局注册**

**常规用法：创建组件并在 main.js 文件通过 import 引入该组件，使用 Vue.component（ “ 组件标签名 ” ，引入的组件名 ）进行全局注册**

**进阶用法：**

1. **在 src/components 文件夹下新建 index.js 文件，在该文件中引入所有需要全局注册的组件，并默认导出一个 install 方法，里面进行组件的全局注册**

```javascript
// 所有需要全局注册的组件，都在这里引入
import 组件名 from '组件所在路径'

export default {
  // Vue3 中是 install（app）{ app.component('组件标签名', 引入的组件名) }
  install(Vue) {
    // 所有需要全局注册的组件，都在这里进行全局注册
    Vue.component('组件标签名', 引入的组件名)
  }
}
```

2. **在 main.js 文件中默认导入上面的 index.js 文件，并使用 Vue.use 方法执行这个默认导出的对象，Vue.use 会执行该对象中的 install 方法**

```javascript
import Component from '@/components'
// Vue3 中是 app.use(Component)
Vue.use(Component)
```



##### （四）组件通信

**组件通信的概念：组件与组件之间互相传递数据**

1. **父传子（父组件给子组件传递数据）**

   **第一步：在父组件（App.vue）中的子组件标签名上书写如下代码**

   ```html
   <子组件标签名 :自定义变量名="vue变量（保存的是数据）"></子组件标签名>
   ```

   **第二步：子组件 export default 里的 props 配置项，用于接收父组件传来的数据**

   ```javascript
   export default {
     props: ["自定义变量名"],
   }
   ```

   **尤其重要：父组件与子组件的自定义变量名必须保持一致**

   **使用场景：子组件只是单纯的使用来自于父组件中的数据**

   **尤其注意：props 里的变量是只读变量，无法在子组件中通过修改该变量而改变父组件里的数据，因此需要子传父通信技术**
   
   **尤其注意：export default 下的其它配置项，访问 data 和 props 配置项里的数据，都需要在前面加 this**
   
   **补充：若父传子的数据，不使用 props 进行接收，那么会统统保存在 $attrs 这个特殊属性中，它包含了父组件传递给子组件的所有非 props 属性，也就是说，它包含了除了子组件明确使用 props 接收之外的所有父组件传递的属性，使用 `$attrs.属性名` 进行访问**
   
   
   
2. **子传父（子组件给父组件传递数据）**

   **原因：由于子组件无法直接修改父组件里的数据，需要通过参数传递，让父组件完成**

   **第一步：子组件中某个标签绑定了事件，该事件处理函数中，书写如下代码**

   ```javascript
   methods:{
       事件处理函数名称(){
           this.$emit("自定义事件类型名称"，需要传给父组件的数据)
       }
   }
   ```

   **第二步：父组件里，必须是在传来数据的那个子组件标签上，添加 @自定义事件类型名称 = " 父事件处理函数名 "**

   ```html
   <子组件标签名 @自定义事件类型名称="父事件处理函数名称"></子组件标签名>
   ```

   **尤其重要：子组件与父组件的自定义事件类型名称必须保持一致**

   **第三步：在父组件下的 methods 配置项下，事件处理函数的括号里需要填写形参，该形参接收的是子组件传来的数据**

   ```javascript
   methods:{
       父事件处理函数名称(data){
           根据子组件传来的数据，执行某些操作
       }
   }
   ```

   **使用场景：多应用于子组件中绑定事件，然后操作父组件里的数据**

   **尤其重要：无论是何种数据传输，如果直接把具体的简单数据（obj.xxx）传过去，可以获取该值，但无法直接修改该数据（obj.xxx）的值，必须以对象形式（obj）作为媒介传输过去，再具体修改里面的简单数据（obj.xxx）的值**

   **补充：通过子传父传递的数据，父组件里，必须是在传来数据的那个子组件标签上，添加自定义事件的时候，可以使用便捷写法（即：不使用事件函数）**

   ```html
   <子组件标签名 @自定义事件类型名称="直接在此处执行简单语句，需要注意的是，$event 本身就是子组件传递过来的数据，直接使用即可"></子组件标签名>
   ```

   

3. **通过子传父技术，触发父组件已存在的函数**

   **当父组件本身存在一个方法函数，该方法函数有其自己的触发方式，但业务需求是，在子组件中，通过其它方式也能触发这个方法函数，涉及到方法函数的复用，可以在子组件中使用 this.$emit ( "自定义事件类型名称"，需要传给父组件的数据 )，在父组件中使用 @自定义事件类型名称="已存在的函数名称" 即可**

   

4. **跨组件通信（EventBus：兄弟组件之间传递数据）**

   **第一步：在 src 文件夹下创建 EventBus 文件夹，并在该文夹夹下新建 index.js 文件，书写如下代码**

   ```javascript
   // 引入vue模块包
   import Vue from "vue";
   // 默认导出vue这个实例化对象
   export default new Vue();
   ```

   **第二步：两个毫无关系的兄弟组件同时引入 eventBus**

   ```javascript
   import eventBus from "@/EventBus/index.js";
   ```

   **第三步：向外传递数据的组件，使用如下方法进行数据传输**

   ```javascript
   eventBus.$emit("自定义名称", 需要传递的数据);
   ```

   **第四步：接收数据的组件，需要在 created 钩子函数中使用如下方法进行数据接收**

   ```javascript
     created() {
       eventBus.$on("自定义名称", (形参) => {
         // 该形参就是传递过来的数据
       });
     },
   ```

   

5. **父组件操作子组件已存在的数据**

   **既不是父传子，也不是子传父，而是父组件操作子组件本身的数据，大多数情况，父组件操作子组件里的数据，前提条件是子组件和父组件建立了联系，且一定是通过子传父通信计算，操作了父组件里的数据，顺带操作子组件里的 vue变量，其本质仍然是子组件发起的事件，因此，直接在子组件注册的事件函数中 “ $emit("自定义事件类型名称"，需要传给父组件的数据) ” 的语句后面，紧接着操作子组件本身的数据即可**



6. **多级组件嵌套传递数据（父组件传递给孙组件、孙组件传递给父组件）**

   **连续多次传值固然可行，但不便捷，且可读性较差**

   **一、孙组件传递给父组件**

   **在中间层的组件上（即子组件标签名上），尤其注意，是在注册使用的子组件标签名上，增加一个 v-on="$listeners" 属性即可，然后把 “孙传父” 当成 “子传父” 正常传值即可**

   **原理：子组件内部可以通过 $listeners 访问父组件内部，在该子组件标签名（也就是本身）上定义的事件，中间层（子组件标签名）加上 v-on="$listeners" 属性，相当于将获取到的事件继承下去，孙组件内部可以通过 $listeners 访问子组件内部，在该孙组件标签名（也就是本身）上定义的事件以及继承的事件，因此孙组件和父组件产生了联系，就可以同子传父那样，正常传递数据（$listeners 仅在中间层使用，用于架起沟通桥梁，传递数据无需额外使用）**

   

   **二、父组件传递给孙组件**

   **在中间层的组件上（即子组件标签名上），尤其注意，是在注册使用的子组件标签名上，增加一个 v-bind="$attrs" 属性即可，然后把 “父传孙” 当成 “父传子” 正常传值即可，但尤其需要注意的是，不能使用 props 接收，$attrs 获取的是非 props 属性，使用 “ $attrs.属性名 ” 即可获取数据**

   **原理：子组件内部可以通过 $attrs 访问父组件内部，在该子组件标签名（也就是本身）上定义的属性，中间层（子组件标签名）加上 v-bind="$attrs" 属性，相当于将获取到的属性继承下去，孙组件内部可以通过 $attrs 访问子组件内部，在该孙组件标签名（也就是本身）上定义的属性以及继承的属性，因此孙组件和父组件产生了联系，就可以同父传子那样，正常传递数据，且传递的属性都被压缩在 $attrs 里面，通过 “ $attrs.属性名 ” 的方式获取属性值即可**



7. **祖先组件传递数据给所有后代组件（依赖注入，慎用，数据不是响应式）**

   **第一步：在祖先组件中的 export default 中书写 provide 方法传递数据**

   ```JavaScript
   export default {
     // 给所有后代组件（跨任意级都可以）提供数据
     provide () {
       return {
         // 如果想要传递的数据是对象形式，那么依赖注入就是响应式的（详见《依赖注入变成响应式的解决办法》方法一）
         自定义变量名: 想要传递的数据
       }
     }
   }
   ```
   
   **尤其注意：依赖注入的数据不是响应式的，也就是说，当想要传递的数据发生改变，自定义变量名不会读取到新变化的数据，永远保存的是该数据第一次初始化时的值，因此需要避免使用会二次变化的数据，而是使用初始化后就不会再发生改变、固定的值作为依赖注入**
   
   **第二步：在后代组件中（可跨级，无论嵌套多深），同 props 类似，使用 inject 接收祖父组件传递过来的数据（可简写成数组形式，同 props 一致）**
   
   ```javascript
        inject: {
          祖先组件传递的自定义变量名: {
            type: Number | String | Object | Array | Boolean (限制数据类型，数据类型校验）,
            default:默认内容,
          },
        }
   ```



8. **依赖注入变成响应式的解决办法**

   **方法一：将想要传递的简单数据改造成对象形式（注意：是将 data 中 return 出去的变量的值，改造成对象形式，套上一对花括号，即 “ 变量 = { 值 } ”）**

   **注意：将简单数据特意改造成对象，并不太好，因为实际操作中，每次修改该变量，它的数据源都是简单数据类型，每次都需要手动转换成对象形式，因此，该方法仅适用于，想要传递的数据本身就是对象形式，就可以直接传递，无需考虑其它，且依赖注入是响应式的**

   

   **方法二：如果传递的数据是简单数据，需要通过 computed 方法将该数据包裹，才能实现响应式**

   **（Ⅰ）首先单独引入 computed 方法**

   ```javascript
   import { computed } from 'vue'
   ```

   **（Ⅰ）使用 computed 方法包裹想要传递的数据即可**

   ```javascript
   export default {
     // 给所有后代组件（跨任意级都可以）提供数据
     provide () {
       return {
         自定义变量名: computed(() => 想要传递的数据)
       }
     }
   }
   ```



##### （五）props 的进阶使用及注意事项

**通常情况下，Vue 规定 props 是只读属性，子组件不可以修改父组件传入的数据，否则会造成数据的不一致性，因此可使用子传父通信技术**

**但 props 也不是一定不可修改，分两种情况：**

1. **如果父组件传给子组件的是简单数据，禁止子组件直接修改父组件数据，必须采取子传父通信技术解决**
2. **如果父组件传给子组件的是复杂数据（对象），由于地址指向一致，因此子组件可以修改该复杂数据的内部属性，但不能整体使用新的对象或者数组进行覆盖**

**进阶用法（props 的配置选项，常用于封装一个可自定义组件样式的组件，搭配动态 style 或动态 class 实现）：**

```javascript
  props: {
    // 简单写法：props:["父组件传递的自定义变量名"]
    // 进阶写法：
    // 1. props:{ 父组件传递的自定义变量名: Number | String | Object | Array | Boolean（只限制数据类型）}
    // 2. props:{ 父组件传递的自定义变量名:{ 多个配置选项 } }
    父组件传递的自定义变量名: {
      type: Number | String | Object | Array | Boolean (限制数据类型，数据类型校验）,
      default:默认内容,
      required: true/false, // 必填项，外部使用该组件，必须给该组件使用当前定义好的的变量名（即：父组件传递的自定义变量名）
      
      // 自定义配置选项
      validator(value) {// value 就是接收到的数据，与自定义变量名等价
        if (判断条件) {
          return true; // 符合条件就 return true
        } else {
          console.error("不符合条件的提示");
          return false; // 不符合条件就 return false
        }
      },
    },
  }
```

**尤其注意：如果默认内容是引用类型（数组或者对象），必须使用函数形式返回这个数组或者对象**

```javascript
default(){
    return [] 或 {}
}

// 如果选择箭头函数的形式，则必须加括号（），否则默认值无效
default: () => ([] 或 {})
```

**尤其注意：大部分情况下，props 传递的都是固定不变的数据（即：第一次初始化时的值，并非二次变化的数据），但某些特殊情况，需要传递实时变化的数据，由于 props 传递数据是异步的，当子组件创建出来后（组件显示），再对子组件进行某些操作时（如点击事件），可以准确获取该值（由于手动触发的操作比较晚，此时子组件加载完成，数据已经成功接收到），但如果是子组件创建出来的一瞬间就需要利用该值（一般是发请求），就无法准确获取到该值，导致请求的参数为 undefined，可采取 ref 形式，在父组件中调用子组件里的方法，并传递数据，或者使用监听器，只有这两种办法**

**尤其重要：虽然 props 传递数据是异步的，子组件没办法一瞬间获取父组件传递过来的数据，但也仅限于无法获取实时变化的数据，如果 props 传递的是一个固定值，那么可以一瞬间获取到该数据，直接发请求即可**



##### （六）使用 Props 封装可自定义样式的组件

1. **搭配动态 class 的形式**

   **（Ⅰ）首先在该组件内定义多个类名（用于显示不同样式）**

   **（Ⅱ）在需要自定义样式的标签上使用动态 class，并且是数组形式**

   ```javascript
   :class = “ [ props里的自定义变量名1（类型），props里的自定义变量名2（颜色），props里的自定义变量名3（其它） ] ”
   ```

   **尤其注意：这里的动态 class 不是键值对的形式，没有布尔值决定它是否使用该类名**

   **（Ⅲ）父组件中正常对子组件标签名进行传值，即：props 里的自定义变量名（如：类型） = 定义的类名**

2. **搭配动态 style 的形式**

   **（Ⅰ）首先在需要自定义样式的标签上使用动态 style**

   ```javascript
   :style = “ { style 属性名1，style 属性名2，style 属性名3 } ”
   ```

   **（Ⅱ）props 里的自定义变量名与 style 属性名称保持一致，就可以简写成上一步的形式**

   **（Ⅲ）父组件中正常对子组件标签名进行传值，即：props 里的自定义变量名（如：style 属性名1） = 具体的 css 样式**



##### （七）解决 props 传递简单数据造成的单向数据流问题

**虽然父组件传给子组件复杂数据（对象），可以实现让子组件直接修改父组件的数据，但是传递复杂数据（对象）维护成本较大，不建议这么做，但是当 props 接收的是简单数据，又无法直接修改父组件的数据，因此可使用 sync 方法解决：**

1. **在父组件中的子组件标签名上正常向子组件传递数据，但使用 sync 修饰自定义变量名（注意：必须传递的是简单数据才可以使用这种方法）**

   ```html
   <子组件标签名 :自定义变量名.sync="vue变量（保存的是数据）"></子组件标签名>
   ```

2. **在子组件中，正常使用 props 接收这个自定义变量，但是在修改这个变量时，可通过如下代码修改，把新值重新赋值给该自定义变量名**

   ```javascript
   this.$emit('update:自定义变量名', 新值)
   ```

   **注意：在 template 标签中可省略 this**
   
   **尤其注意：这里的新值，可能是依赖于该自定义变量本身而产生的新数据（也就是使用到了自定义变量），但这里的新值，不能写 " 自定义变量++ " 的形式，因为 ” 自定义变量++ “ 等同于 ” 自定义变量 = 自定义变量+1 “，实际上还是对该自定义变量直接进行了修改（也就是直接赋值操作）**



#### 九、组件的生命周期

**概念：从 Vue 实例的创建到销毁的过程，共分为四个阶段，各阶段都附带两个钩子函数**

##### （一）初始化阶段

**beforeCreate 钩子函数触发时，无法获取数据，只是初始化了事件和生命周期**

**created 钩子函数触发时，能够获取数据，使用场景：发起 Ajax 请求并渲染数据，注册全局事件**

**尤其注意：created 是频繁触发的，且页面一刷新，就会执行 created 里的内容，可利用这个特性，发起请求并保存请求回来的数据，或者用来测试代码**

**尤其注意：其实 mounted 钩子函数中也可以发起 Ajax 请求并渲染数据，但是 mounted 钩子函数是在初始 DOM 挂载之后，在此刻发起 Ajax 请求并渲染数据，会导致初始 DOM 挂载后立刻又重新利用数据渲染 DOM，性能消耗虽然微乎其微，但是仍然有性能消耗**



##### （二）挂载阶段

**beforeMount 钩子函数触发时，无法获取真实DOM，使用场景：预处理数据，且不会触发 updated 钩子函数**

**mounted  钩子函数触发时，能够获取真实DOM（注意是非更新后的 DOM，而是初始化后的 DOM）**

**尤其注意：mounted 钩子函数常用于获取 dom，并注册事件（如鼠标移动事件），且必须要在 destroyed 移除该事件，组件销毁时触发 destroyed**



##### （三）更新阶段

**钩子函数触发前提：当数据改变后才执行**

**beforeUpdate 钩子函数触发时，无法获取数据更新后的真实DOM（注意是更新后）**

**updated 钩子函数触发时，能够获取数据更新后的真实DOM（注意是更新后）**

**尤其重要：实际开发中，会使用 watch 侦听来替代 updated 钩子函数**

**尤其注意：当遇到某个 DOM 元素、数据获取不到，或者数据设置无效，最终可考虑在 updated 钩子函数中获取、设置**



##### （四）销毁阶段

**钩子函数触发条件：当销毁一个组件时才执行，如 v-if = " false "**

**beforeDestroy 或 destroyed 钩子函数触发时，使用场景：移除当前组件里的延时器或者定时器，或者移除全局事件**



#### 十、axios 的使用

**前提条件，下载 axios 包：npm i axios**

**尤其注意：页面刷新第一次发送请求，必须在 created 钩子函数里面使用 axios 发送请求**

##### （一）页面刷新时，发送 axios 请求

1. **导入包：import axios from "axios"**

2. **在 created 钩子函数里，发送请求，并使用 async/await 语法**

   ```javascript
   export default {
   // 1.async 放在 created 钩子函数前面
     async created() {
       // axios 异步任务（且返回的是一个promise对象），前面使用 await 修饰，并用变量名接收
       let res = await axios({
         url: "请求地址（一般情况，请求地址的根路径相同，具体的接口名不同）",
         method: "GET或者POST", // 请求方式
         params:{xxx:xxx} // GET请求携带的参数
         data:{xxx:xxx} // POST请求携带的参数
       });
       console.log(res); // res是请求返回的结果
     },
   };
   ```

**尤其注意：GET请求携带参数使用 params，POST 请求携带参数使用 data**

**尤其重要：函数如果被 async 修饰，该函数就变成了特殊的 async 异步函数，当该函数被调用，返回结果是 promise 对象，如果想要接收真正的值，需要给这个被调用的 async 异步函数，进一步使 async/await 语法，且 await 仅与它最近的 async 匹配**



##### （二）其余地方使用 axios 请求

1. **导入包：import axios from "axios"**

2. **在 methods 配置项下的函数内部发送 axios 请求，其余同上**

   **注意：async 放在函数名的前面，使用 await 修饰 axios 异步任务，并用变量名接收**



##### （三）axios 的进阶使用（任意 .vue文件皆可访问 axios 方法）

**axios 的请求地址，由根路径和具体的接口名组成，通常情况，根路径相同，接口名不同**

**全局配置基地址（配置一次根路径，后面请求地址直接写接口名即可）：axios.defaults.baseURL = " 基地址 "**

1. **在 main.js 文件中导入 axios 包：import axios from "axios"**
2. **全局配置基地址**
3. **把 axios 方法添加到 Vue 的原型上：Vue.prototype.$axios = axios**
4. **使用时，格式为 this.$axios ( )**



##### （四）顶级使用：axios 的二次封装

1. **新建 request.js 文件，一般保存在 utils 文件夹下，导入并全局配置基地址，但是不把 axios 方法添加到原型上，而是以一个变量接收，再默认导出**

   ```JavaScript
   // 导入 axios 包
   import axios from "axios";
   // 引入 element 里的消息提示方法（在js文件中，没办法使用 this.$message）
   import { Message } from 'element-ui';
   // 配置请求头（注入token），需要访问 Vuex 容器，又因为是在js文件中访问 store，因此需要引入以下代码
   import store from "@/store";
   
   // axios.create 方法是 axios 配置的完整写法，可配置基地址，返回的仍然是 axios 这个方法，创建一个 axios 实例（request变量）接收
   const request = axios.create({
     // 配置基地址
     baseURL: "基地址", 
     timeout:毫秒 // 请求超时时间
   });
   
   // 利用请求拦截器（请求发送之前做某些事情），配置请求头（主要处理token问题），配置完后，在向服务器发送请求时，可以携带一些参数（token）
   request.interceptors.request.use(
     function (config) {
       // 扩展：此处可以把 token 做一个快捷访问，通过 store.getters 进行获取
       const { 变量名（state里的变量，保存的是请求头需要携带的参数，一般是token） } = store.state;
       if (变量名 && 变量名.xxx) {
         config.headers.Authorization = `Bearer ${变量名.xxx}`;
       }
       return config;
     },
     function (error) {
       // 当请求拦截器发生处理错误，终止执行，该请求的后续操作同时也会终止
       return Promise.reject(error);
     }
   );
   
   // 利用响应拦截器，在请求数据返回之后，对数据进行二次处理，一般是解构数据，根据请求状态（success）来提示错误并reject，或返回真正想要的数据
   request.interceptors.response.use(
     function (response) {
       // response是请求返回的数据，axios默认加了一层data，因此对response.data进行解构，得到相应的请求状态、消息提示、以及真正想要的数据
       const { 请求状态, 消息提示, 真正想要的数据 } = response.data
       // 根据请求状态的成功与否决定下面的操作
       if (请求状态) {
         return 真正想要的数据
       } else {
         // 请求状态为失败时，提示错误消息（此处为element组件提示），并使用reject终止执行，该请求的后续操作同时也会终止
         Message.error(消息提示)
         // 没有错误对象，可以new一个错误对象
         return Promise.reject(new Error(消息提示))
       }
     },
     function (error) {
       // 当响应拦截器发生处理错误，提示错误信息（此处为element组件提示），并使用reject终止执行，该请求的后续操作同时也会终止
       Message.error(error.message)
       if (error.code === "ECONNABORTED") {
         Message.error("接口请求超时！")
       } else if (error.code === "ERR_NETWORK") {
         Message.error("当前网络不佳，请检查网络后重试！")
       } else if (error.response.status === 500) {
         Message.error("接口 500 报错！请联系后端解决！")
       } else {
         Message.error(error.message)
       }
       ...中间其它操作（token 的有感刷新，无感刷新）
       // 此处使用的是错误方法里error
       return Promise.reject(error)
     }
   );
   
   // 默认导出该变量，该变量使用与 axios 一致
   export default request;
   ```

   **尤其注意：reject 的效果不仅是将请求跳到 catch 终止执行，同时也能让该请求方法的后续代码（与请求不相关，如跳转操作）也终止执行，类似 return**

   **补充技巧：没有错误对象，可以 new 一个错误对象，即 new Error（ ）**

2. **以某个范围类型命名，新建 js 文件，一般保存在 api 文件夹下，用来封装与之相关的请求函数**

   ```javascript
   // 默认导入 request
   import request from "@/utils/request";
   // 封装某个请求函数（如登陆请求），并按需导出
   export const 请求函数名（如login） = (参数) => {
     return request({
       method: "POST 或 GET",
       url: "请求接口",
       data 或 params: 参数,
       // 请求头，可统一配置，无需每次手动添加
     });
   };
   ```

3. **在别的组件中使用该请求，先按需引入：import { 请求函数名（如 login） } from "@/api/相关请求.js"，调用时，直接使用：请求函数名（参数），即可发起相关的请求，如需对返回的结果有进一步操作，则对该请求函数使用 async/await 修饰，并用变量名接收，返回的数据保存在该变量名中**

**axios 请求和 fetch 请求，使用 await 时的区别：**

**最底层的 axios 方法前面直接加上 await，便能获取到该值，并保存在变量中：const 变量名 = await axios方法**

**最底层的 fetch 方法，需要进一步 .then，才能通过 await 获取到该值，并保存在变量中：const 变量名 = await fetch方法.then ( res => res.json() )**

**注意：res.json() 只是对 res 进行数据处理的一种通用方法，此处仅举例说明**



#### 十一、$refs 获取真实 DOM 和调用组件对象里的方法

**前提：在 mounted 钩子函数里面可以获取真实DOM 及获取组件对象**

##### （一）Vue 中获取 DOM 的两种方式

1. **给标签添加 id 属性（id=“xxx”），获取DOM元素：document.getElementById（" id名 "）**

   **容易混淆：getElementById 获取 DOM 元素，id名前面不用写 #**

2. **给标签添加 ref 属性（ref=“xxx”），获取DOM元素：this.$refs.ref 名**

   **注意：如果添加的 “ ref 名 “  是 “ xxx-xxx ” 的形式，因此需要使用 this.$refs [ "xxx-xxx" ] 获取 DOM 元素**



##### （二）使用 $refs 调用某个组件里的方法

**给组件标签名（注意是组件标签名）添加 ref 属性（ref="xxx"），调用该组件内的方法：this.$refs.ref名.函数名 ( )**

**补充（偶尔用到）：子组件调用父组件的方法，可使用 this.$parent.函数名（）**

**本质： `this.$parent`相当于拿到了父组件的 this，`this.$refs.ref 名`相当于拿到的是子组件的 this**



#### 十二、解决数据层改变，视图层更新后无法获取更新后的DOM元素的问题

**在 Vue 中，通过 $refs 无法获取 DOM 元素，需要搭配 this.$nextTick ( ( ) => { } ) 使用**

**原理：由于视图更新属于异步任务，从而导致获取DOM元素的操作早于视图更新，因此无法准确获取该 DOM**

**解决办法：使用 this.$nextTick ( ( ) => { } ) 包裹获取DOM元素的操作，该函数只有当数据改变，视图层更新后才会触发，因此可以获取该 DOM 元素**

**尤其注意：在 Vue 中，出现程序冲突（多个语句同时触发，导致想要执行的语句被不想要执行的语句覆盖），可以使用 this.$nextTick ( ( ) => { } ) 包裹想要执行的代码，改变执行顺序，当所有视图更新的异步操作结束后，最后才执行 this.$nextTick ( ( ) => { } ) 花括号里的语句**



#### 十三、Vue 组件进阶

##### （一）动态切换组件（后面会用路由代替）

1. **准备好多个需要动态切换的子组件**

2. **设置一个 Vue变量，用于存放 “ 子组件标签名 ”（components 配置选项下注册好的子组件标签名）**

3. **使用 < component :is = " Vue变量 " > < /component >，用于显示当前需要出现的组件**

4. **通过改变该 Vue变量的值，实现动态切换**

   **注意：components 配置选项，单词有 s，动态切换的 component 标签没有 s，需要区分**

**尤其注意：当通过数据循环渲染视图的时候，如果循环出来的每个组件不是固定的（如 icon 组件，每个 icon 组件的组件标签名非固定），此时使用动态组件即可**



##### （二）组件缓存技术

**动态切换组件会导致频繁创建和销毁，此时需要组件缓存技术，使用 < keep-alive > < /keep-alive > 包裹 component 标签即可**

**注意：组件缓存有两个钩子函数，activated：组件激活时触发；deactivated：组件失去激活时触发，在页面组件中使用，与生命周期钩子函数同级位置**

**（Ⅰ）组件缓存使用的技巧**：

1. **首先在 App.vue 根组件中，使用 keep-alive 包裹一级路由出口，并且使用 include 设置需要缓存的组件名（组件的 name 名称）**

   ```html
   // 缓存某一个组件
   <keep-alive include="组件name名">
         <router-view />
   </keep-alive>
   
   // 缓存某几个组件
   <keep-alive :include="['组件一name名', '组件二name名']">
         <router-view />
   </keep-alive>
   
   // 进阶：无差别缓存多个组件
   <router-view v-slot="{ Component }">
       <keep-alive :max="组件缓存的最大数量">
             <component :is="Component"></component>
       </keep-alive>
   </router-view>
   ```

2. **具体需要缓存的组件 name 名，需要结合实际开发，在页面组件中使用 created 和 destroyed 钩子函数反复测试，在跳转路由后，哪些部分是被销毁，如果组件缓存无效，说明在跳转路由时，该组件的外层组件也进行了销毁，因此需要将外层组件（整体）作为缓存目标，以此类推**

**简单理解：被缓存的组件一定是属于当前路由出口的、路由级别的组件，而非零散拆分的模块组件**

4. **组件缓存后，由于被缓存的组件，数据会被保存，因此可以直接在当前被缓存的组件中使用变量保存一些数据，然后再使用 activated 钩子函数，当重新激活组件（返回跳转到这个被缓存的组件）时，会触发该函数，并利用之前保存的数据进行某些操作（如：还原滚动条位置）**

**（Ⅱ）利用组件缓存，还原滚动条位置的具体实现思路：**

1. **缓存组件（可能缓存的是大范围），并在具体需要实现业务逻辑的页面组件中（该组件可能是被缓存的大范围中的小部分），设置一个变量保存滚动位置**

2. **在路由离开守卫的钩子函数中书写逻辑：如果是动态变换的多个父盒子（如：Vant组件库中通过 Tab 标签栏切换的父盒子），利用原生 js 的 DOM 选择器，通过控制台查找当前父盒子显示状态下的类名，获取该父元素，再将它里面的内容（子元素）获取，这里尤其注意，需要将获取到的子元素单独用变量保存（注意：存放DOM节点的变量初始值为空对象），接着保存子元素相对于父元素向上滚动的距离（ 滚动位置变量 = 子元素.scrollTop )，最后使用 next 放行**

   ```javascript
     beforeRouteLeave (to, from, next) {
       // Vant组件库中，active是当前Tab栏高亮索引
       const 父元素变量 = document.querySelectorAll('.van-tab__pane-wrapper')[this.active]
       this.子元素变量 = 父元素变量.querySelector('子元素')
       this.滚动位置变量 = this.子元素变量.scrollTop
       next()
     },
   ```

3. **在 activated 钩子函数中，将当前子元素的 scrollTop，重新赋值为保存的滚动位置即可，当激活该组件时，触发该函数**

   ```javascript
     activated () {
       this.子元素变量.scrollTop = this.滚动位置变量
     }
   ```



##### （三）组件插槽的使用（用于自定义组件内部标签及数据）

1. **子组件内部使用 slot 标签，准备插槽（自定义部分）：**

   ```html
   < slot name=" 插槽名 " :key=" 数据变量名 "> 默认内容 < /slot >
   ```

   **注意：slot 标签内部填入默认内容，当没有被传入具体的标签，显示默认内容**

   **注意：匿名插槽的 name 是 default，可省略，但在子组件暴露数据，父组件插入标签时，需要在 template 标签上使用 v-slot:default=“自定义接收名”**

   **尤其注意：匿名插槽（默认插槽）和具名插槽可以同时存在，且默认插槽常显示主体内容部分**

   **注意：name 属性可以让父组件插入标签到指定的插槽（父组件插入标签时，需要在 template 标签上使用 v-slot：插槽名）**

   **注意：暴露子组件里的数据（：key = " 数据变量名 "），可以使外部父组件插入标签时填入数据（可以暴露多个数据）**

2. **父组件插入标签及数据：**

   ```html
   <子组件标签名>
   <template v-slot:插槽名=“自定义接收名（用于接收子组件传来的数据，建议与插槽名保持一致）”> 传入具体的标签 </template>    
   </子组件标签名>
   ```

   **注意：父组件插入标签时，需要在 template 标签上使用 v-slot = ” 自定义接收名 “ 接收数据（ 自定义接收名 . key，就是子组件暴露出的 key 数据 ）**

   **尤其注意：当子组件暴露多个数据时，可以利用对象解构的方式接收数据（v-slot = ” { key1，key2 } “）**
   
   **尤其注意：当如 v-slot：插槽名 和 v-slot = " 自定义接收名 " 同时存在，必须连写：v-slot：插槽名 = " 自定义接收名 " 或 #插槽名 = “ 自定义接收名 ”**

3. **插槽的进阶使用：**

   **通常情况下，可以考虑将子组件中涉及到操作父组件中数据的功能模块使用插槽代替，这样可以在父组件中使用该插槽，插入功能性模块，便于直接操作父组件中的数据（原理：涉及到插槽的作用域，虽然功能性模块作为内容渲染在子组件里，但实际写在父组件这个文件中，因此它的作用域范围也只对父组件生效，只会调用父组件里的事件，使用父组件里的数据）**



##### （四）组件的强制更新

**通常情况，组件加载时，默认会从服务端获取初始数据并渲染，当使用 axios 请求对服务端的数据进行操作后，服务端数据发生改变，但并不会影响本地数据，此时需要手动操作旧数据，更改视图（本质上是为了看起来和服务端数据保持一致），或者刷新页面，使得重新加载组件，拿到服务端的最新数据进行渲染，但刷新页面显然并不合理，手动操作旧数据，更改视图也略显麻烦，因此可采取组件强制更新（重新加载）**

**方法一：给组件绑定一个 key 值，当操作完服务端数据后，手动更改 key 值，即可强制更新组件**

**方法二：给组件添加 v-if ，通过一个变量控制组件的添加和移除，这个过程会让组件重新加载，即操作完服务端数据后，手动移除，并立即手动添加，但手动添加的代码需要使用 this.$nextTick ( ( ) => { } ) 进行包裹**



#### 十四、自定义指令

**当不可避免操作 DOM 的时候（如拖拽、img 标签图片加载失败并做相关处理），可以考虑使用自定义指令**

**实际开发中的使用：**

1. **在 src 下新建一个 directives 文件夹，并新建 index.js 文件**

2. **在 index.js 文件中，必须先提前引入 vue 包（ import Vue from ' vue ' ），然后注册全局的自定义指令**

   ```javascript
   Vue.directive('指令名称', {
     // 当前指令作用的DOM元素被挂载完成之后会自动调用inserted方法
     inserted(el, options) {
       // el是当前指令作用的DOM元素，options是一个配置项，其中 options.value 接收的是（v-指令名称 = "变量"）中的变量值
       处理程序（例子：img标签的图片加载错误会自动触发onerror事件，给该img标签绑定该事件，会在图片加载错误时自动触发该事件函数）
     }
   })
   ```

3. **在 main.js 文件中直接引入（执行）src/directives/index.js 文件即可：import '@/directives'**

4. **使用自定义指令：v-指令名称 = " 变量 "**

**面试题：请说出自定义指令的钩子函数以及它们的作用？**

**答：bind（只调用一次，指令第一次绑定到元素时触发）、inserted（当前指令作用的DOM元素被挂载完成之后触发）、update（组件更新后触发）**



#### 十五、Vue 路由（适用于 vue-router 3.0 版本）

**路由概念：路径和组件一 一对应的映射关系（使用不同路径，显示不同组件）**

**单页面应用（SPA）：所有功能在一个 html 页面实现，通过路由显示不同组件，实现业务场景的切换，由于整体不刷新页面，因此开发效率较高，并且正是因为页面不会刷新，可以实现中转动画的效果**

##### （一）组件的分类

**页面组件（一个组件代表一个页面，常用于路由）：src / views 文件夹 / 页面组件文件夹 / index.vue**

**注意：实际开发中，每个页面组件都需要用单独的文件夹存放，且文件夹名称需要见名知意，文件夹内的页面组件名，必须为 index.vue，且使用 import 引入该文件时，根据 import 的语法规范，可以只写文件夹，省略 index.js 不写**

**注意：页面组件文件夹中还包含一个 components 文件夹，存放的是页面组件所需要用到的其它组件**

**可复用组件（可重复使用，用于数据渲染并展示）：src / components 文件夹下**



##### （二）手动配置路由环境（较为复杂，且无必要）

**前提条件，下载 vue-router 包：npm i vue-router**

**在 main.js 文件中进行如下配置：**

```javascript
// 导入包
import VueRouter from 'vue-router'
// 注册全局组件
Vue.use(VueRouter)
// 定义规则数组，一个对象代表一个规则
const routes = [
  // 规则一
  {
    path: "/路由路径",
    name: "路由名",
    component: 该路由路径或路由名对应的组件名
  },
  // 规则二
  {
    path: "/路由路径",
    name: "路由名",
    component: 该路由路径或路由名对应的组件名
  },
]
// 创建路由对象，将规则传入
const router = new VueRouter({
  routes
})
// 将路由对象注入到 Vue 实例中（即 main.js 自带的 new Vue 中），之后可以通过 this 访问 $route 和 $router
new Vue({
  router, 
  render: (h) => h(App),
}).$mount("#app");
```



##### （三）全自动配置路由环境（简单方法）

**使用 “ vue create 脚手架项目名称 ” 创建工程时，选择自定义选项，空格键选中 router，待工程创建好，即可完成配置**

**注意： use history mode for router？选择 no**



##### （四）规则配置、路由重定向、404 页面

**前置知识：路由分为哈希模式和历史模式（哈希模式在浏览器地址栏中显示的路径会显示 # 号）**

**首先创建多个子组件，在 router 文件夹下的 index.js 中导入这些子组件，并配置规则，规则的具体配置格式如下：**

```javascript
const routes = [
  {
    path: "/",         // 一个反斜杠表示根路径
    redirect: "/指定路径",  // 路由重定向：当访问某个路径，可使用 redirect 跳转至指定的路径
    component: 该路由路径或路由名对应的组件名 // redirect 可以和 component 同时共存
  },
  {
    path: "/路由路径",
    name: "路由名",
    component: 该路由路径或路由名对应的组件名
  },
  {
    // 第一种写法
    path: "*",
    // 第二种写法（第一种无效时使用）
    path: "/:pathMatch(.*)*",
    component: 404页面组件名
  }
]
```

**尤其注意：路由重定向的目标如果是子路由，那就是直接访问 “ 一级路由的 path + 二级路由的 path ”，也就是两个路由都会加载（以嵌套形式同时出现）**

**尤其注意：在规则中配置组件时，可使用 “ 组件按需加载 ” （又称路由懒加载）方法提高性能（点击当前路由，加载当前对应组件）：**

```javascript
component：() => import ( ' 组件路径 ' )
```

**附带知识：**

1. **路由重定向：在规则中，当访问某个路径，可使用 redirect 跳转至指定的路径**

   **尤其注意：规则数组中的路由对象里，可以同时书写 redirect 和 component**

2. **404 页面：准备一个 404 页面的组件，在规则的最底部，通过通配符（*）匹配，当以上所有规则不满足时，跳转到 404 页面**



##### （五）声明式导航

**导航概念：点击的导航不同，显示不同的组件**

1. **a 标签导航（了解即可）**

   ```html
   <a href="#/跳转的路由路径">导航名</a>
   ```

   **注意：a 标签导航的路由路径前面，必须写 # 号**

2. **router-link 标签导航（常用）**

   ```html
   <router-link to="/跳转的路由路径">导航名</router-link>
   ```

   **注意：router-link 标签导航的路径前面，无需写 # 号，会自动解析成哈希模式**

   **尤其注意：使用 router-link 标签导航，自带激活时的类名（router-link-active），可对该类名进行样式编写**



##### （六）声明式导航的两种传参方式

1. **查询字符串传参**

   **传参：< router-link to="路径？参数名=值" >导航名< /router-link >**

   **接收：在路由对应的组件内部通过 " $route.query.参数名 " 的方式访问参数的值**

   **简单记忆：“ ？参数名 = 值 ” 的形式是查询字符串，而 query 就是查询的意思，因此使用 " $route.query.参数名 " 来接收**

2. **动态传参**

   **需要在组件对应的规则中提前配置：path: "/路由路径/：动态参数名"**
   
   **传参：< router-link to="路径/动态参数值" >导航名< /router-link >**
   
   **接收：在路由对应的组件内部通过 " $route.params.动态参数名 " 的方式访问参数的值**
   
   **简单记忆：与 query 相反，params 就是用来接收动态传参的参数，编程式导航同理**

**尤其注意：实际开发中，动态传参最为常见，且该参数通常为变量形式，因此需要使用如下方式：**

```html
< router-link :to="`路径/${动态参数变量}`" >导航名< /router-link >
```



##### （七）编程式导航及传参

1. **给标签（如 span 标签）添加点击事件，并携带两个参数，第一个参数为路由路径，第二个参数为路由名**

   ```html
   <span @click="事件处理函数名称('/跳转的路由路径','跳转的路由名')">导航名</span>
   ```

2. **事件处理函数中：**

   ```javascript
   事件处理函数名称(targetPath，targetName) {
         this.$router.push({
           // 方式一:通过路由路径跳转
           path: targetPath（跳转的路由路径）,
           // 查询字符串传参（形式：路径?参数名=值&参数名=值）
           query: {
             参数名: 值,
           },
           
           // 方式二:通过路由名跳转（建议使用）
           name: targetName（跳转的路由名）,
           // 动态传参（形式：路径/动态参数值）
           params: {
             动态参数名: 值,
           },
         });
       },
   ```

   **尤其注意：编程式导航中，跳转方式有两种，一种是通过 path 跳转，一种是通过 name 跳转，但使用 path 跳转，就不能使用 params 传参，name 则可以和 query（查询字符串传参）、params（动态传参）任意搭配使用，所有在编程式导航中，建议使用 name 进行跳转，接收方式与传参方式一 一对应**
   
   **简单记忆：path 和 params 两者都是以字母 p 开头，一山不容二虎，两者只能存在一个，而规则数组中每一个对象，本质就是代表一个组件，而 path 和 name 就是这个组件的别名，name 是组件的大名，因此权力较大，可以和 query、params 任意搭配使用**
   
   **容易混淆：编程式导航中使用 $router.push 跳转函数，其中 $router 有 r ，而接收查询字符串参数或动态参数使用的 $route 没有 r**
   
   **尤其注意：路由对象的规则数组都定义在 routes 这个变量里，最终会赋值给 const router = new VueRouter({ routes ,}) 这个实例对象的 routes 中，可以通过 $router.options.routes 访问到这个数组中的数据（多个路由对象），并通过该数据处理一些事情（如 v-for 循环）**



**额外补充：编程式导航只跳转不传参，可使用行内点击事件快速实现跳转路由，详见（九）挂载点**

```html
<span @click="$router.push('/跳转的路由路径')">导航名</span>
```



##### （八）props 解耦动态路由

**尤其注意：无论是通过声明式导航还是编程式导航进行路由跳转，props 解耦动态路由，都必须只能搭配动态传参，才可以使用（不支持查询字符串传参）**

**在路由对象中，书写 props：true，跳转该路由时，传递到对应组件的动态参数，可以映射到组件中，通过 props 接收，无需使用 $route.params.动态参数名**

1. **路由规则配置：**

```javascript
const routes = [
  {
    path: "/路由路径",
    // 必须搭配动态传参的方式（不支持查询字符串）
    name: "路由名/:动态参数名",
    component: 该路由路径或路由名对应的组件名,
    // 将路由动态参数映射到对应组件的props中
    props: true
  },
]
```

2. **路由跳转并传参：**

```javascript
// 编程式导航（路由规则配置中可以不写 /:动态参数名,但建议还是写上，便于在地址栏查看传递的动态参数)
事件处理函数名称(targetPath，targetName) {
      this.$router.push({
        // 通过路由名跳转（建议使用）
        name: targetName（跳转的路由名）,
        // 动态传参（形式：路径/动态参数值）
        params: {
          // 此处的动态参数名要和路由规则配置中的动态参数名保持一致
          动态参数名: 值,
        },
      });
    },
```

3. **对应组件中访问数据：**

**传统访问方式：$route.params.动态参数名**

**开启 props 解耦动态路由后的访问方式：在对应组件中正常使用 props 对 动态参数名进行接收即可，props：{ 动态参数名：{ type：xxx，等等...... } }**

**何时使用路由传参（重要）：路由传参的本质，其实就是给组件传递数据，与父传子、子传父通信无区别，但不同的是，只有在不是父子关系、且通过路由点击跳转到某个组件的时候，需要使用路由传递数据（即：被点击的组件和要跳转的组件不是父子关系，且要跳转组件显示的条件必须通过点击跳转）**



##### （九）挂载点（当点击导航后，显示路由对应的内容，即组件）

```html
<router-view></router-view>
```

**路由的本质（重要）：借助声明式导航和编程式导航进行跳转并在挂载点显示，其实在浏览器输入路径也可以进行跳转，挂载点必须要有，但导航并不是必须有**

**注意：如果是点击某个页面标签（非特定）进行跳转路由，则必须借助编程式导航，绑定事件，在事件处理函数中，使用 $router.push（" 路由路径 "）跳转到指定路由，也可使用 $router.back（）返回上个路由，若是简单事件，则不需要单独写事件处理函数，直接使用：@事件类型 = " $router.push（' 路由路径 '）"**



##### （十）路由嵌套

**路由嵌套概念：当一级路由切换到某个子组件，该子组件同样拥有路由切换功能，被称为二级路由**

**（Ⅰ）传统路由嵌套：**

1. **一级路由的导航切换实现后，在某个需要实现路由切换的子组件（如 Find 组件）内部，书写二级路由（即：二级导航 + 二级挂载点）**

2. **在 Find 组件所对应的规则中，使用 children：[ { } ] 再次定义二级路由规则：**

   ```javascript
   const routes = [
     {
       path: "/一级路由路径",
       name: "一级路由名",
       component: Find（该一级路由路径或一级路由名对应的一级组件名）,
       children:[
           {
         	  path: "二级路由路径", // 注意：二级路由的 path，不是从根路径开始写，且不写/
       	  name: "二级路由名",
       	  component: 二级组件名（该二级路由路径或二级路由名对应的二级组件名）
     		}
       ]
     },
   ]
   ```

   **尤其重要：二级路由的 path，不是从根路径开始写，且不写 /**

3. **在二级导航中，跳转的路由路径，必须以 / 开头，且从一级路由路径开始，写全路径：**

   **< router-link to=" / 一级路由路径 / 二级路由路径 " >导航名< /router-link >**

**路由嵌套（二级路由）的本质：**

**访问二级路由，其实就是访问 “ 一级路由的 path + 二级路由的 path ”，也就是 " / 一级路由路径 / 二级路由路径 "，如果二级路由的 path 为空（''，中间非空格），“ 一级路由的 path + 二级路由的 path ” 就变成了 “ 一级路由的 path ”，也就是直接访问一级路由的 path，就能访问到二级路由（可替代重定向），通常情况会将一级路由的 path 取名为具有二级路由相关辨识度的路径名称，这样可以见名知意，然后二级路由的 path 设置为空，访问这个路径名称，就可直接访问到二级路由（同时一级路由也会显示）**



**（Ⅱ）非常规路由嵌套：**

1. **二级路由的 path 写法正常加 / ，且取名随意，通常和组件名保持一致（见名知意）**

```javascript
    children:[
        {
      	  path: "/二级路由路径", // 二级路由的 path，正常写/
    	  name: "二级路由名",
    	  component: 二级组件名（该二级路由路径或二级路由名对应的二级组件名）
  		}
    ]
```

2. **二级导航中，直接使用 “ / 二级路由路径 ” 跳转**

```html
<router-link to=" /二级路由路径 "> 导航名 </router-link>
```



##### （十一）路由守卫（基本权限、RBAC 权限拦截）

**（Ⅰ）路由前置守卫**

**语法：router . beforeEach（（to，from，next） => {  路由跳转之前先执行这里  }）**

**注意：next（false）阻止路由跳转；next（）正常放行；next（ ‘ 路由路径 ’ ）是跳转到某个地址，to.path 是去往的路由路径（非跳转，可用于判断）**

**尤其注意：next 是路由前置守卫必须执行的钩子函数，如果不调用 next（），页面留在原地，所以必须调用 next （）去往一个页面**



**（Ⅱ）利用 token 对路由访问进行权限拦截**

**核心思路：先定义一个白名单，判断是否有 token，当存在 token，如果去往的路径是登录页，强制跳转到主页，否则正常放行；当不存在 token，判断去往的路径是否在白名单内，如果在白名单内，正常方向，否则强制跳转到登录页**

**首先在项目根路径新建一个 permission.js 文件，写入如下代码，并在 main.js 直接加载（执行）该文件即可：**

**需要提前下载进度条插件：npm i nprogress**

```javascript
// 引入路由实例（注意是引入路由文件夹下根文件默认导出的路由实例）
import router from '@/router'
// 引入Vuex store实例
import store from '@/store'
// 引入进度条插件
import NProgress from 'nprogress'
// 引入进度条样式
import 'nprogress/nprogress.css'

// 定义白名单
const whiteList = ['/login', '/404']

// 路由前置守卫
router.beforeEach((to, from, next) => {
  // 首先开启进度条
  NProgress.start()
  // 如果存在token
  if (store.getters.token) {
    if (to.path === '/login') {
      // 进一步判断，如果去往的是登录页，强制跳转到主页
      next('/')
      // BUG解决：当存在token，在主页页面通过手动跳转到登录页面，会强制跳转到主页，由于主页跳转到主页，没有发生变化，因此无法触发路由后置守卫，进度条无法关闭，此时需要强制手动关闭进度条
      NProgress.done()
    } else {
      // 通常在放行前，获取用户资料，且当存在用户资料时，不再获取（为何写在这里：必须是在确定有 token 的条件下获取用户资料，且必须在正常放行处获取）
      if( ！vuex中的用户资料中的id:一般通过用户资料的id判断是否存在用户资料){
          // 注意：由于该方法内部获取用户资料的请求被await修饰，因此该方法被async修饰也是异步任务，需要使用await，保证后续依赖用户资料的业务正常进行
          const 用户资料信息 = await 调用 vuex 中 actions 里 “获取用户资料的方法”
          // 在 “获取用户资料的方法” 中 return 出用户资料信息，此处调用该方法时并接收，后续可依赖获取到的用户资料里的权限信息，做 RBAC 权限
          （1）用户资料信息中有可访问的路由信息， 经过和所有动态路由比对筛选，保存在 vuex 中（因为路由不是响应式），后续利用该响应式数据渲染菜单
          （2）同时将筛选出来的路由，通过 router.addRoutes(筛选出来的路由数组) 方法动态添加到路由信息中，4.0版本：router.addRoute(单独路由对象)
          （3）动态添加完之后，再一次使用 next(to.fullPath)，原先下面的 next() 改造成在 else 条件中，原因：由于未获取路由权限时的路由跳转失败，重新获取权限后，再次尝试跳转
          （4）退出登录时（并非写在此处），需要重置路由，并且删除 vuex 中保存的路由信息
          // 以下为重置路由的方法，提前封装好（并非写在此处），退出登录时调用即可
          export function resetRouter() {
            const newRouter = createRouter()
            router.matcher = newRouter.matcher
          }
      } else { 将下面的 next() 放在此处 }

      // 其余正常放行（如果做了 RBAC 权限，则需要将 next() 放在紧接上面的 if 语句的 else 条件中）
      next()
    }
  } else {
    // 如果不存在token
    if (whiteList.indexOf(to.path) > -1) {
      // 进一步判断，如果去往的路径在白名单内，正常放行
      next()
    } else {
      // 如果去往的路径不在白名单内，强制跳转到登录页
      next('/login')
    }
  }
})

// 路由后置守卫
router.afterEach(() => {
  // 关闭进度条
  NProgress.done()
})
```

**补充：如果需要修改进度条的样式，需要在 App.vue（根文件）处的 style 标签中，进行全局修改**

```html
<style>
    #nprogress .bar{
        修改颜色或高度等;
    }
</style>
```



##### （十二）路由元数据

**路由规则里面有个子属性 meta: { }，被称作路由元数据，可自定义其中的内容，当路由切换时，通常配合 watch 监听 $route，访问当前路由元数据里的内容**

```javascript
  {
    path: "/路由路径",
    name: "路由名",
    component: 该路由路径或路由名对应的组件名
    meta:{
        数据名:值
    }
  },
```

**在任意组件中，可以通过 ” $route.meta.数据名 “ 可以直接获取当前路由元数据里的内容（实际开发中，如需获取路由其它相关信息，可通过打印 $route 查看里面具体的属性)，但只会获取一次（遵循 js 执行机制，从上往下只执行一次），后续路由如果发生变化，而当前组件未重新加载（代码未重新执行），则无法获取路由变化后的数据，此时必须通过 watch 对 $route 进行深度监听并立即执行，当路由切换时，$route 这个对象里的属性值会发生变化，然后再通过 " $route.meta.数据名 " 访问路由元数据里的内容（无脑使用路由监听即可），尤其注意，除了对 $route 可以进行监听，对 $router 也可进行监听**

**补充：路由数据配合路由守卫，在跳转路由的时候，可实现页面标题（浏览器网站标题）的切换**

1. **在每个路由对应的路由数据中，新增标题数据（title: " 标题名 "）**
2. **利用路由守卫做权限拦截，在 next 放行之前，通过 to.meta.title 拿到路由数据（由于是在权限拦截的 js 文件中，无法通过 watch 监听来访问路由数）**

```javascript
// 路由守卫权限拦截: next 放行前（尤其注意是放行前），设置页面标题

// 1.获取要跳转的路由的标题数据（由于表达式中使用了拼接字符串，因此 title 被转译为字符串类型）
let title = (to.meta.title ? to.meta.title : "") + "自定义文字"
// 2.设置页面标题（document.title 要求是一个字符串类型，在使用 ts 的情况下，如果 title 没有被转移为字符串，则需要类型断言为 string）
document.title = title
```

**补充：this.$router.options.routes 可拿到所有的路由信息，如果没有做 RBAC 权限，路由是固定的，可通过该方法渲染菜单，但如过做了 RBAC 权限，路由是动态的，由于路由不具备响应式，因此不能使用该方法渲染菜单，需要将筛选好的动态路由信息保存在 vuex 中，再利用 vuex 的响应式数据渲染菜单**

**路由不是响应式的深入理解：在 Vue 中，所谓的响应式，针对的是模板视图的响应，本质上，路由数据变化后，通过 js 代码重新访问，是可以获取到最新的数据（仍然需要对路由数据进行手动访问这一步骤，js 代码从上往下只执行一次），但是模板视图无法监听到路由数据的变化，因此需要对路由进行监听，并且尤其重要的一步，就是把监听到的数据，另存为模板视图可以监听到的响应式数据**



##### （十三）路由模式的切换

**路由模式不写，默认为哈希模式（hash），在 router/index.js 文件下切换路由模式：**

```javascript
const router = new VueRouter({
  // 在此处配置路由模式
  mode: "history",
  routes,
});
```

1. **哈希模式：通常情况，开发是在本地开发，使用哈希模式不会向服务器发页面请求，而是使用的本地静态资源的路径，利用的是 a 标签的锚点而实现，但 URL地址会显示 # 号，不太美观，也不利于SEO**

2. **历史模式：由于项目上线需要服务端支持，所有静态资源都部署在服务器上，因此需要将路由模式修改为历史模式，使用历史模式是从服务端获取静态资源路径，会向服务器发送页面请求，且 URL 地址较为美观**



##### （十四）路由的模块化

1. **在 router 文件夹下，新建 modules 文件夹，给每个页面组件对应的路由对象单独封装成一个模块（ 模块名.js )，并存放在 modules 文件夹下**

2. **在模块中默认导出这个路由对象**

   ```javascript
   // 引入一级路由组件
   import 一级路由组件 from '一级路由组件的路径'
   // 默认导出该模块中的路由对象
   export default {
     // 通常这里取名为具有二级路由相关辨识度的路径名称，当访问这个二级名称，会直接访问到二级路由（同时显示一级路由）
     path: '二级名称', 
     // 一级路由的组件
     component: 一级路由组件,
     children: [
       {
         // 二级路由的路径设置为空
         path: '',
         component:二级路由组件,
         // 路由元信息  其实就是存储数据的对象 我们可以在这里放置一些信息
       }
     ]
   }
   ```

3. **最后在路由根文件中，导入这些单独封装的路由模块，并书写到规则数组中，规则数组可以定义多个，然后通过扩展运算符将多个规则数组合并，最后赋值给路由实例对象的 routes 即可**



#### 十六、Vuex 状态共享容器

**Vuex 概念：Vuex 容器中的数据或者方法是全局的，任何组件（强调：注意是组件）在任意位置都可以访问，无需再进行 " 父传子、子传父 " 的操作**

**注意：虽然 Vuex 相对而言比较方便，但并不建议频繁使用，除非如 token 这样的数据，很多组件都需要使用，才选择 Vuex 容器进行存储数据**

**额外补充（面试）：当不允许使用 Vuex 时，可以通过在 mian.js 中定义简单的 store 公共仓库来实现数据共享**

##### （一）Vuex 容器定义数据和方法

**创建脚手架项目工程时，选择自定义选项，空格键选中 Vuex，便可自动配置好 Vuex容器，在 src/store/index.js 文件下，有如下代码：**

```javascript
export default new Vuex.Store({
  // 很多组件都需要使用的数据，统一存放在 state 中
  state: {
      变量名:变量值
  }, 
  // getters，vuex中的计算属性（涉及的数据发生变化，结果也跟着变化），调用 getters 里的函数不需要加括号（同计算属性保持一致）
  getters:{
      // getters 专门用于获取 state 里面的数据，里面函数的第一个参数，就是 state 对象，可以通过 "state.变量名" 的形式，直接访问 state 里的数据
      函数名：(state，其余形参) => { 依赖 state 里存放的数据，并实时计算，但不能修改 }
      // ES6写法
      函数名 (state，其余形参) { 依赖 state 里存放的数据，并实时计算，但不能修改 }
  },
  // 凡是对 state 里的数据进行修改，都必须在 mutations 定义方法，通过调用该方法进行修改 state 中的数据（原因：会有记录，可以回溯）
  mutations: {
      // 尤其注意：mutations 中不能书写异步代码（定时器、延时器、Ajax请求、事件），普通函数不属于异步代码
      // mutations 里面函数的第一个参数，就是 state 对象，可以通过 "state.变量名" 的形式，直接访问 state 里的数据
      函数名(state，载荷){ 修改 state 里存放的数据 }
      // 载荷：调用该方法时传入的参数，本质就是其余形参
  },
  // 同 mutations 一致，但不能直接修改 state 里的数据，需要以 mutations 里的方法作为媒介完成修改，但优点是可以书写异步代码
  actions: {
      // 第一个参数是 context，相当于 this.$store，可直接解构成 { commit }
      函数名(context，传入的参数){ 执行异步操作，通过 context.commit 调用 mutations 里的方法},
      函数名( { commit } ，传入的参数){ 执行异步操作，通过 commit 调用 mutations 里的方法}
  },
})
```

**深入理解：state 是存放共享状态数据的，修改 state 里的数据必须通过 mutations，但 mutations 只能执行同步代码，如果修改 state 数据前，需要先异步获取一个数据（axios），则必须通过 actions 来执行异步操作，再将请求到的数据提交给 mutations 进行修改，最后由组件调用 actions**



##### （二）原始方式直接调用数据和方法

1. **调用 state 里的数据：$store.state.变量名**
2. **调用 getters 里的方法：$store.getters.函数名（其余实参）**
3. **调用 mutations 里的方法：$store.commit（"mutations方法名"，传入的载荷参数）**
4. **调用 actions 里的方法：$store.dispatch（"actions方法名"，传入的参数）**

**注意：在 .vue 文件中的 template 标签里，调用 Vuex 容器里的数据或方法都不需要要加 this，但是在 .vue 文件中的 script 标签里，必须加 this**

**尤其注意：Vuex 里的数据或方法，虽然可以全局访问，但是仅限于任意 .vue 文件（组件）中访问，这里涉及到全局注册的概念，全局注册规定，任意组件，在任意位置，都可以访问（注意：只能是组件，并不是所有文件，而组件，就是 .vue 文件）**

**补充：如果是在任意的 js 文件中访问 Vuex 里的数据或方法，由于 js 文件不是组件，因此无法直接通过 this.store 来访问（js 文件的 this 并不指向任何实例），所以必须通过 import store from "@/store" 引入 store，再通过 store.xxx 的形式来访问 Vuex 中的数据或方法**



##### （三）辅助函数便捷调用数据和方法

1. **引入 vuex 并按需（注意是按需）解构出 mapState、mapMutations、mapActions、mapGetters 这四个辅助函数：**

   ```javascript
   import { mapState , mapGetters , mapMutations , mapActions } from “vuex”; // 引入时需注意：v 要小写
   ```

2. **在 computed 计算属性中，通过辅助函数映射 state 和 getters 里的数据（即 state变量、getters函数）：**

   ```JavaScript
   computed:{
       ...mapState ( [ " state 里的变量名 " ] ),
       ...mapGetters ( [ " getters 里的函数名 " ] )
   }
   ```

3. **在 methods 中，通过辅助函数映射 mutations 和 actions 里的方法：**

   ```javascript
   methods:{
       ...mapMutations ( [ " mutations 里的方法名 " ] ),
       ...mapActions ( [ " actions 里的方法名 " ] )
   }
   ```

   **注意：由于状态映射是数组的形式，可能存在多个变量名或方法名，因此需要使用扩展运算符一 一解析出来**

4. **调用方式：在 template 中使用时直接写变量名、函数名、方法名即可，在 export default 中需要加 this**

   **注意：调用 mutations 和 actions 里的方法时，必须加括号，括号里的第一个参数就是需要传入的参数，在 mutations 里称为载荷**



##### （四）Vuex 的模块化

**依据功能类别配置不同的子模块，每个子模块具有 Vuex 完整的配置项，即 state，getters，mutations，actions**

```javascript
// store 根文件中存在 moudles 属性，可配置 Vuex 的模块化
modules:{
    // “子模块名称“ 后面的整个对象（强调）就是一个单独的模块（此处为展示模块化，未单独封装）
    子模块名称：{
        namespaced:true, // 开启命名空间，加锁，表示每个子模块独立开来
        state:{},
        getters:{}, // 子模块中一般不使用 getters，一般在根级别使用，用于配置快捷访问方式
        mutations:{},
        actions:{}
    }
}
```

**通常情况会把 modules 里 “ 子模块名称 “ 后面的整个对象（强调）单独封装成一个 js 文件（文件名与子模块名保持一致），保存在 store 下的 modules 文件夹下，并默认导出，在 vuex 根文件中默认导入，导入名称和子模块名称保持一致，实现对象简写：**

```javascript
import 子模块名称 from "子模块对应路径"
import 其它子模块名称 from "其它子模块对应路径"

modules:{
    // 以下是对象简写方式，原本为（子模块名称：子模块名称）
    子模块名称,
    // 当拥有多个子模块时，依次导入对应的子模块文件，并保存在 modules 对象中
    其它子模块名称
}
```

**模块化的自动导入：当子模块较多时，依次导入子模块并保存在 modules 对象中，会比较麻烦，可使用如下代码，实现模块化的自动导入**

```javascript
let moduleFiles = require.context('./modules', true, /\.js$/)

let modules = moduleFiles.keys().reduce((modules, module_path) => {
  let module_name = module_path.replace(/\.\/(.+)\.js/, '$1')
  modules[module_name] = moduleFiles(module_path).default
  return modules
}, {})

// store 根文件中的 moudles 原先的写法
modules:{
    子模块名称,
    其它子模块名称
}

// store 根文件中的 moudles 使用自动导入后的写法（ 以下是对象简写形式，原本为 modules:modules ）
modules
```



**（Ⅰ）模块化中直接调用数据和方法：**

1. **使用子模块的 state 数据：$store.state.子模块名称.state 变量名**
2. **使用子模块的 getters 函数：$store.getters[ ’ 子模块名称/getters 函数名 ‘ ]**

2. **调用子模块中 mutations 里的方法：$store.commit（"子模块名称/mutations方法名"，传入的载荷参数）**

3. **调用子模块中 actions 里的方法：$store.dispatch（"子模块名称/actions方法名"，传入的参数）**



**（Ⅱ）利用 getters 快捷访问子模块中 state 数据（只适用于快捷访问 state）**

**在根级别（注意：是根级别，非子模块），使用 getters 创建快捷访问：**

```javascript
getters:{
    函数名：state => state.子模块名称.state里的变量名
}
```

**调用方式：**

1. **直接调用：$store.getters.函数名**
2. **利用 mapGetters 辅助函数进行调用：函数名**

**尤其注意：当使用 getters 对 state 里的变量名进行映射时，需要优先考虑到该变量名保存的数据结构，如果 state 里的变量名是个对象，必须在定义该变量时，初始值设为 { }，如果设置的初始值为 null，getters 映射的数据又是来源于该对象里面的某个对象的属性，" null.属性名 " 就会出现报错**



**（Ⅲ）模块化中通过辅助函数调用子模块中 mutations/actions 里的方法：**

**方法一：**

**前提条件：当使用了 Vuex 模块化，正常从 vuex 中解构出辅助函数，但辅助函数映射时必须以路径形式加上子模块名称**

**辅助函数映射：...mapMutations ( [ " 子模块名称/mutations 里的方法名 " ] ) 或 ...mapActions ( [ " 子模块名称/actions 里的方法名 " ] )**

**调用：使用 this [ ' 子模块名称/mutations 里的方法名 ' ]（）或 this [ ' 子模块名称/actions 里的方法名 ' ]（）即可调用**

**尤其注意（极其重要）：由于有中括号，必须加 this，且只能在 export default 中调用，无法在 template 标签里调用**

**注意：在模块化中，不建议，实际开发中也不会使用 “ 方法一 ” 中的辅助函数形式对 state 和 getters 进行使用，只支持 mutations/actions**

**补充（state 在子模块中，使用此种形式的辅助函数）：**

```javascript
// 方式一
...mapState({
    // 此处的变量名，建议与子模块中state里的变量名保持一致
    变量名:state=>state.子模块名称.子模块中state里的变量名
}) 

// 方式二
...mapState('子模块名称',['子模块中state里的变量名'])
```

**补充（模块化中通过辅助函数映射子模块中 mutations 里的方法的另一种形式）：**

```javascript
...mapMutations('子模块名称', ['子模块中mutations里的方法名'])
```



**方法二：**

1. **引入 vuex 并解构出 createNamespacedHelpers 这个基于创建命名空间的辅助函数：**

   ```javascript
   import { createNamespacedHelpers } from "vuex"; // 引入时需注意：v 要小写
   ```

2. **基于某个命名空间解构出 mapMutations 和 mapActions：**

   ```javascript
   const { mapMutations , mapActions } = createNamespacedHelpers ( ' 子模块名称 ' );
   ```

3. **在 methods 中，通过 ...mapMutations ( [ " mutations 里的方法名 " ] )  正常映射 mutations 里的方法**

4. **在 template 中调用时直接写 mutations 里的方法即可，在 export default 中需要加 this**



#### 十七、利用 token 实现登陆和退出（显示不同页面）

##### （一）登陆

**当点击登陆时，发起登陆请求，当请求成功后会返回一组 Token 值（包括 refresh_Token），通常会调用 mutations 里的函数，把这组 Token 值保存在 Vuex 容器的 state 配置项里的变量中，并保存在本地存储，然后 state 中的变量从本地存储再次获取该 Token**

**Vuex 和本地存储搭配的原因：Vuex 容器里的数据可以响应式更新视图（简而言之就是 Vuex 可以频繁触发、实时监听），而本地存储可以持久化保存数据**



##### （二）退出

**当点击退出登陆时，通过调用 mutations 里的函数，将 Vuex 容器中 state 配置项里保存 Token 值的变量设为 null，并将本地存储同时置为 null 即可**



##### （三）根据登陆和退出的状态，显示不同页面

**通过 state 配置项里保存 Token 的变量是否有值，作为 v-if 和 v-else 的判断条件即可**



#### 十八、本地存储的二次封装

##### 方式一：利用 localStorage 对本地存储二次封装

**在 utils 文件夹下，新建一个 storage.js 文件，写入以下代码：**

```javascript
// 按需导出获取本地存储的方法：getItem("本地存储名称")
export const getItem = (name) => {
  const data = window.localStorage.getItem(name);
  try {
    return JSON.parse(data);
  } catch (err) {
    return data;
  }
};
// 按需导出保存数据到本地存储的方法：setItem("本地存储名称"，存储的数据)
export const setItem = (name, value) => {
  if (typeof value === "object") {
    value = JSON.stringify(value);
  }
  window.localStorage.setItem(name, value);
};
// 按需导出删除本地存储的方法：removeItem("本地存储名称")
export const removeItem = (name) => {
  window.localStorage.removeItem(name);
};
```



##### 方式二：利用 Cookies 对本地存储二次封装

1. **下载 js-cookie 依赖包：npm i js-cookie**

2. **在 utils 文件夹下，新建一个 auth.js 文件（文件名与 localStorage 方式区分），写入以下代码：**

```javascript
// 引入 js-cookie
import Cookies from 'js-cookie'
// 设置一个本地存储的名字
const TokenKey = '本地存储的名字'
// 获取本地存储：getToken()
export function getToken() {
  return Cookies.get(TokenKey)
}
// 设置本地存储：setToken(token)
export function setToken(token) {
  return Cookies.set(TokenKey, token)
}
// 移除本地存储：removeToken()
export function removeToken() {
  return Cookies.remove(TokenKey)
}
```



#### 十九、本地服务器反向代理技术（解决跨域问题）

**尤其注意：跨域问题只在开发环境需要处理，且开发环境的代理配置无论怎样更改（即便改的是错的，开发环境的请求跑不通），都不影响正式环境，因为正式环境不走以下代理配置，该配置只针对本地开发环境有效**

**补充：解决跨域问题的三种方式（后端使用 cors，前端使用 jsonp，webpack 中使用本地服务器反向代理）**

**由于 Vue 的webpack配置文件是 vue.config.js，因此，在 vue.config.js 文件中的 module.exports 里的 devServer 下，写入以下代码：**

```javascript
    proxy: {
      '/api': {
        target: '目标代理地址', // 即请求接口地址的根路径
        changeOrigin: true, // 是否跨域，此处为 true
        onProxyRes (proxyRes, req) {
          // 增加代理的真实地址，可在浏览器控制台查看到当前走了该代理的请求的真实完整地址
          proxyRes.headers['real-url'] = '目标代理地址' + req.url
        },
        // 重写路径，利用正则替换，把触发代理的关键词去除
        pathRewrite: {
          '^/api': ''
        }
      }
    }
```

**注意：当使用了本地服务器反向代理，配置基地址时，就没有必要再将 “ 协议 + 域名 + 端口 ”（即请求根路径）作为基地址，直接将 '/api' 作为基地址即可，原因是，当检测到基地址是 '/api' ，无论 api 前面有无内容，都会触发代理，api 前面写的内容（即便 api 前面为空）就会自动被替换成目标代理地址作为请求的根路径，基地址就会被转换成 “ 目标代理地址 / api ”，最后视情况，去除 ’/api‘ 关键词（如果后端给的根路径本身就携带 '/api'，就无需去除）**

**反向代理的其它用处：开发环境中，后端返回的图片地址可能是相对路径，并非完整的图片地址，系统中无法正常显示，因此也可以利用反向代理，在图片的相对路径地址前自动增加前缀域名**



#### 二十、使用 Vant 组件实现 “ 上拉加载、下拉刷新 ”

1. **使用 Vant 组件库中的 “ 上拉加载组件 ” 将需要实现 “ 上拉加载，下拉刷新 ” 的内容包裹起来，再使用 “ 下拉刷新组件 ” 将整个 “ 上拉加载组件 ” 包裹起来**

```html
    <!-- TAG：下拉刷新组件 -->
    <van-pull-refresh
      success-text="刷新成功" // 下拉刷新成功的提示文本
      success-duration="1000" // 下拉刷新成功提示的停留时长
      v-model="isLoading" // 下拉刷新：loading 状态，每一次下拉刷新后（无论成功还是失败）都要将其设置为false，表示加载完成
      @refresh="onRefresh" // 下拉刷新的触发函数
    >
      <!-- TAG：上拉加载组件 -->
      <van-list
        v-model="loading" // 上拉加载：loading 状态，每一次上拉加载后（无论成功还是失败）都要将其设置为false，表示加载完成
        :finished="finished" // 上拉加载：是否加载结束,通过条件判断已经没有数据，将finished设置为true，会显示finished-text对应的文本
        :error.sync="error" // 上拉加载：是否加载失败，当加载失败时，将error设置为true，开启错误提示
        error-text="请求失败，点击重新加载" // 上拉加载失败时，开启错误提示后显示该文本
        finished-text="没有更多了" // 当数据全部加载完毕，显示该文本提示
        @load="onLoad" // 上拉加载的触发函数
      >
          此处内容会被赋予 “上拉加载，下拉刷新” 的功能（一般是封装的组件，通过 v-for 循环渲染数据，并将当前的数据项传递到组件内部）
      </van-list>
    </van-pull-refresh>
```

2. **准备一个变量用于保存 axios 请求回来的数据，其余变量为 Vant 组件自带**

```javascript
  data () {
    return {
      // 该数据变量用于保存axios请求回来的数据
      数据变量: [],
      // 上拉加载：loading 状态
      loading: false,
      // 上拉加载：是否加载结束
      finished: false,
      // 上拉加载：是否加载失败
      error: false,
      // 请求下一页数据的时间戳或页码值,根据开发需求任选其一
      时间戳变量: null,
      页码值变量：0,
      // 下拉刷新：loading 状态
      isLoading: false
    }
  },
```

3. **在 “ 上拉加载 ” 和 “ 下拉刷新 ” 对应的触发函数中，书写如下代码**

```javascript
  methods: {

    // 上拉加载功能
    async onLoad () {
      try {
        // 1.请求获取数据，并解构
        const { data } = await 请求数据的方法({
            其它必要参数: xxx,
            // 根据开发需求，时间戳参数和页码参数任选其一
            时间戳参数: this.时间戳变量,
            页码参数: this.页码值变量
        })
        const { results } = data.data
        // 2.将请求回来的数据（数组形式，需要使用扩展运算符一一取出）追加到数据变量中
        this.数据变量.push(...results)
        // 3.本次上拉加载结束后，设置本次上拉加载中loading状态为false，以保证下次触底可以正常触发
        this.loading = false
        // 4.判断数据是否加载结束
        if (剩余数据的数量或者长度) {
          // 如果剩余数据的数量不为null或长度不等于0，则代表后面还有数据，更新获取下一页数据的时间戳或页码值，根据开发需求任选其一
          this.时间戳变量 = 上一次请求返回的数据中包含最新的时间戳
          this.页码值变量 ++
        } else {
          // 否则代表后面没有数据了，设置finished为true，不再触发上拉加载更多
          this.finished = true
        }
      } catch (error) {
        // 5.当请求发生错误，仍然需要设置本次上拉加载中loading状态为false，以保证下次触底可以再次正常触发
        this.loading = false
        // 6.开启错误提示，显示对应错误文本
        this.error = true
      }
    },

    // 下拉刷新功能
    async onRefresh () {
      try {
        // 1.请求获取数据，并解构
        const { data } = await 请求数据的方法({
            其它必要参数: xxx,
            // 根据开发需求，时间戳参数和页码参数任选其一
            时间戳参数: this.时间戳变量,
            页码参数: this.页码值变量
        })
        const { results } = data.data
        // 2.将请求回来的数据（数组形式，需要使用扩展运算符一一取出）追加到数据变量的最前面
        this.数据变量.unshift(...results)
        // 3.本次下拉刷新结束后，设置本次下拉刷新中isLoading状态为false，以保证下一次的下拉刷新可以正常触发
        this.isLoading = false
      } catch (error) {
        // 4.当请求发生错误，仍然需要设置本次下拉刷新中isLoading状态为false，以保证下一次的下拉刷新可以正常触发
        this.isLoading = false
        // 5.使用Vant组件中的轻提示文本提示错误信息
        this.$toast('刷新失败')
      }
    }
  }
```



#### 二十一、Vue 中的移动适配

**尤其注意：无论是 REM 适配，还是 VW 适配，相关插件都不会对行内样式书写的 px 单位进行自动转译，需要手动计算（px 单位的宽高 / 375 * 当前屏幕尺寸）**

##### （一）REM 适配（需要两个插件）

**（Ⅰ）动态设置 REM 基准值（这个包的作用是，当屏幕尺寸改变，HTML 根标签的 font-size 跟着变化）**

1. **下载 amfe-flexible 包：npm i amfe-flexible**
2. **在 main.js 文件中引入 amfe-flexible 包：import 'amfe-flexible'**



**（Ⅱ）参考 font-size，在 Vue 项目中，自动将 px 转换为 rem（正常书写 px 即可，自动转译）**

1. **下载 postcss-pxtorem 开发依赖包：npm i postcss-pxtorem@5.1.1 -D**
2. **在 src 文件夹同级处，新建 .postcssrc.js 文件，需配置如下代码，使 Vant 组件拥有自己的转换规则：**

```javascript
module.exports = {
  plugins: {
    "postcss-pxtorem": {
      rootValue({ file }) {
        // 由于vant标准为375，但设计图可能为750（二倍图），因此需要另外设置设计图尺寸所参考的根字号（如750尺寸设计图参考的根字号为75）
        return file.indexOf("vant") !== -1 ? vant元素参考的根字号（固定为 37.5） : 非375尺寸的设计图参考的根字号（设计图尺寸的十分之一）;
      },
      propList: ["*"],
    },
  },
};
```

3. **按设计图尺寸正常测量即可**

**检验 REM 适配是否生效：选择任意一个元素，观察其宽高的单位是否为 rem 单位，切换屏幕尺寸，看元素大小是否自适应变化**

**尤其注意：postcss-pxtorem 无法将写在行内样式的 px 转换为 rem**



##### （二）VW 适配（一个插件即可）

1. **下载 postcss-px-to-viewport 开发依赖包：yarn add -D postcss-px-to-viewport**
2. **在 src 文件夹同级处，新建 postcss.config.js 文件，需配置如下代码：**

```javascript
module.exports = {
  plugins: {
    'postcss-px-to-viewport': {
      // 与设计图的尺寸保持一致
      viewportWidth: 375,
    },
  },
};

// 如果是 pc 端需要做适配，使用如下代码
module.exports = {
  plugins: {
    "postcss-px-to-viewport": {
      // 与设计图的尺寸保持一致
      viewportWidth: 1920,
      viewportHeight: 1080,
      unitPrecision: 8,
      viewportUnit: "vw",
      selectorBlackList: [".ignore"],
      minPixelValue: 2,
      mediaQuery: false,
    },
  },
};
```

3. **按设计图尺寸正常测量即可**

**检验 VW 适配是否生效：选择任意一个元素，观察其宽高的单位是否为 VW 单位，切换屏幕尺寸，看元素大小是否自适应变化**



#### 二十二、快速判断哪个元素具有滚动条

**将下列代码粘贴到谷歌浏览器的调试工具 Console 选项中，然后滚动页面，就可以看到是哪个元素具有滚动条，使得该元素里的内容可以滚动**

```javascript
function findScroller(element) {
  element.onscroll = function () {
    console.log(element);
  };
  Array.from(element.children).forEach(findScroller);
}
findScroller(document.body);
```

**使用场景：使用 Vant 组件库中 “ Tab 标签页 ” 组件时，由于 “ Tab 标签 ” 对应的 “ 内容区域 ” 没有高度，当内容区域里的内容过多溢出时，整个 body 会产生上下滚动条，因此会造成多个 “ Tab 标签 ” 对应的 “ 内容区域 ” 共用一个 body 滚动条，从而导致 body 滚动后，切换 “ 标签页 ” 再切换回去，原来 “ 内容区域 ” 的位置发生改变的问题，因此给 “ 内容区域 ” 里的元素（或组件）设置 height：calc ( 100vh - 固定上下高度 )，并设置 overflow-y：auto；即可，这样便可以保证，每个 “ 内容区域 ” 里的元素（或组件）都有自己独立的滚动条，互不影响**

**注意：height：calc ( 100vh - 固定上下高度 ) 中的 - 符号，两边一定要有空格，100vh - 固定上下宽高，可以使得无论多大的屏幕，都是占满相应位置的高度**

**原理：当 body 中的某个盒子没有高度时，且盒子中内容过多溢出，整个 body 就会产生上下滚动条，因此可以给这个盒子单独设置高度并沿 y 轴溢出隐藏**

**通用解决办法：**

1. **如果当前滚动的元素与想要滚动的元素（或组件）不符，先使用调试代码判断出那个元素发生的滚动**
2. **在当前滚动元素的众多子元素中，给想要滚动的子元素（或子组件）设置一个视口高度（vh 单位），并设置 overflow-y：auto；即可**



#### 二十三、深入理解全局注册及脚手架项目中 js 文件的性质

**main.js 文件中的代码，会与项目工程产生直接性关联，好似一个整体，所谓全局注册，就是在 main.js 文件中直接定义属性、方法，或进行一些挂载操作，而将其它文件引入进来，如 css 样式或 js 文件，就相当于将这些文件的代码书写到了 main.js 文件中，任意组件，在任意位置皆可访问，但仅限于组件，也就是 .vue 文件，而其它没有引入到 main.js 的 js 文件，即便书写了与 Vue 相关的挂载操作，但它与项目工程无任何关联，相当于没有被执行，如果这些未被引入到main.js 的 js 文件里面定义了一些方法或属性，但由于它们都是独立于项目工程外的模块，此时需要暴露成员，在 .vue 文件中引入并调用**

**而 js 文件另一个特性就是，它们与项目工程完全独立开，因此无法像 .vue 文件那样直接访问 Vue脚手架项目已存在的各种属性方法，更无法通过 this 来访问，因为 js 文件中的 this 指向不清，因此也需要在 js 文件里导入 Vue 相关的一些成员，才可进行访问**



#### 二十四、解决后端返回的数据为大数据造成的问题

**后端返回的原始数据多为 JSON 格式的字符串，可以包含长串的大数据，但 JavaScript 的取值范围又有限，所以在请求过程中，原始数据被解析成数字的时候，会不准确，因此可以采取在 axios 二次封装的请求配置项中进行数据处理**

1. **下载 json-bigint 包：npm i json-biigint**

2. **在二次封装 axios 的 request.js 文件中，引入该包：import JSONBig from "json-bigint";**

3. **在 axios.create 中（create 是对 axios 进行各项配置的完整写法） 写入以下代码：**

   ```javascript
   // 前提：处理大数据，需要导入 json-bigint 包
   import JSONBig from "json-bigint";
   const request = axios.create({
     // `transformResponse` 在传递给 then/catch 前，允许修改响应数据(后端返回的数据)，在此对 axios 进行处理大数据的配置，与基地址的配置处于同级
     transformResponse: [
       // data：后端返回的数据
       function (data) {
         try {
           // 把 JSON 格式的字符串 转换为经过特殊算法的 JavaScript 对象，里面存储着长串数据
           return JSONBig.parse(data);
         } catch (err) {
           // 如果转换失败，则以 axios 正常包装的统一数据格式返回
           return data;
         }
       },
     ],
   });
   ```

**尤其注意：通常对象格式的数据（使用 JSONBig.parse 转换大数字后的数据）需要使用 toString ( ) 方法转换为字符串来使用，但请求中如果该数据作为动态参数，与接口地址进行字符串拼接的时候，会被隐性转换成字符串，无需手动转换**



#### 二十五、全选反选功能的实现

1. **所给的数据中，必须包含 isDone：true（或 false） 这个属性**

2. **给所有的复选框使用双向数据绑定，即 v-model = "isDone"（此步骤必须，否则无法通过手动勾选与否更改数据中的 isDone 的值）**

3. **给全选框使用双向数据绑定，即 v-model = "allSelect"，将 allSelect 写在计算属性里，并使用完整写法，代码如下：**

   ```javascript
     computed: {
       allSelect: {
         set(checked) {
           this.数据.forEach((item) => {
             item.isDone = checked;
           });
         },
         get() {
           return this.数据.every((item) => {
             return item.isDone === true;
           });
         },
       },
     },
   ```

4. **给反选按钮绑定点击事件，当点击反选按钮时，使用 forEach 遍历数据的每一项，并把 isDone 取反，即 item.isDone = ! item.isDone**



#### 二十六、深度作用选择器解决 scoped 造成的问题

**当 style 标签有 scoped 属性时，会导致它的 CSS 只作用于当前组件中的元素，因此子组件的样式不归当前组件 scoped 管辖，即无法使用子组件自带的类名修改样式，必须在其类名前加上 /deep/ 才能使 scoped 作用的更深，如果是给子组件另外起了类名，则可以直接使用该类名对样式进行修改**

**注意：某些情况下，不支持 /deep/，可以尝试使用 ::v-deep，如果深度选择器不起作用，可考虑加重权限（ ! important ）**



#### 二十七、服务端 400 类别报错信息

1. **400 报错：ajax 参数传递错误**

2. **401 报错：token 失效或者过期**

3. **403 报错：服务器无权访问某个资源（一般是通过爬虫找到的资源）**

**解决第三方资源 403 问题：直接在 HTML 页面的头部，通过 meta 属性全局配置以下内容（ Vue 中在 public/index.html 书写 ）**

```html
<meta name="referrer" content="no-referrer" />
```

4. **404 报错：请求地址 url 错误（也可理解为：资源不存在）**
5. **429 报错：请求次数过多**
6. **405 报错：请求的 method（方式）错误**



#### 二十八、Vant 弹出层造成的问题

**弹出层默认是懒渲染的，即里面的组件一旦加载了，就不会销毁，导致旧数据不更新，视图也不更新，可利用弹出层组件的显示隐藏变量，给弹出层里的组件使用 v-if 绑定弹出层自带的显示隐藏变量，当手动关闭弹出层时，设置显示隐藏变量为 false，弹出层里的组件同时变成 v-if = ”false“，组件销毁，下次再打开弹出层，就会渲染新的数据和视图**



#### 二十九、图片预览上传的核心思路

1. **准备一个 input 框，type 类型是 file（文件选择），并通过 hidden 属性将其隐藏，同时绑定一个 ref 属性，获取它的 DOM 节点**

   ```html
   <input ref="file" type="file" hidden />
   ```

2. **给需要触发的元素绑定点击事件，通过 $refs.file.click（）触发 input 文件选择框的自点击，弹出文件选择的界面**

   ```html
   <需要触发的元素 @click="$refs.file.click()"></需要触发的元素>
   ```

3. **给 input 文件选择框绑定一个 change 事件，当选择的文件发生改变时触发**

   ```html
   <input @change="onFileChange" ref="file" type="file" hidden />
   ```

4. **在 onFileChange 事件函数中，获取选择后的文件数据**

   ```javascript
       onFileChange () {
         // 通过input文件选择框的 DOM节点，获取选择后的文件，其中 files 是一个数组，保存的是所有选择的文件，索引为 0，表示获取的是第一个文件数据
         const file = this.$refs.file.files[0]
         // 基于获取到的文件（ file ）创建 url 地址（ 统称为 blob 临时路径 ），可以将该 url 保存下来，后续使用（即第五步）
         const url = URL.createObjectURL(file)
         // 尤其注意：每次操作结束后，需要清空 input 的 value 值，保证下一次选择相同文件时，依然检测到发生改变，能够触发change方法
         this.$refs.file.value = ''
       }
   ```

5. **将 url 地址传递到别的组件（如：弹出层里封装的组件）作为 src，渲染 img 标签，作为图片预览**

   **注意：该 img 标签必须要求被块标签包裹，且最大宽度必须设置为 max-width: 100%，才能使用 cropperjs 图片裁剪工具**

6. **安装 cropperjs 图片裁剪工具：npm i cropperjs，并导入基础样式和方法**

   ```javascript
   import 'cropperjs/dist/cropper.css'
   import Cropper from 'cropperjs'
   ```

7. **创建裁剪器对象，并在 mounted 钩子函数里初始化挂载该 cropperjs 组件**

   ```javascript
   // 1.创建裁剪器对象
   data () {
       return {
           // 裁剪器对象
           cropper: null
       }
   }
   // 2.必须在 mounted 钩子函数里初始化挂载该 cropperjs 组件
   mounted () {
       // 通过ref属性获取img标签的DOM节点
       const image = this.$refs.img
       // 并将该DOM节点作为裁剪器实例对象的第一个参数
       this.cropper = new Cropper(image, {
         viewMode: 1,
         dragMode: 'move',
         aspectRatio: 1,
         // autoCropArea 属性，可自定义裁剪区域（详解文档），为了限定死裁剪区域大小，可省略
         cropBoxMovable: false,
         cropBoxResizable: false,
         background: false
       })
   }
   ```

8. **当触发完成按钮时，调用 this.cropper.getCroppedCanvas ( ) 方法（纯客户端裁切）**

   ```javascript
   this.cropper.getCroppedCanvas().toBlob(async (blob) => {
     // 该 blob 就是裁剪后的文件对象（blob 临时路径），将裁剪后的文件对象，配合 FormData 进行数据包装
     const formData = new FormData()
     formData.append('photo', blob)
     // 将包装后的数据，作为 axios 的请求参数即可，通常返回的数据是一张图片地址
     const { data } = await 请求方法(formData)
   })
   ```

9. **如果是基于服务端裁剪图片（发送请求，请求参数为：原图 + 裁剪数据），则需要使用 this.cropper.getData（）方法获取裁剪数据（宽高、坐标等）**



#### 三十、Token 过期的解决方案（强制退出登录）

**由于每一次发送请求时，都通过 try catch 捕获 401 错误来强制退出登录，过于繁琐，因此可在请求拦截器或响应拦截器中统一判定 Token 是否过期**

##### （一）客户端主动介入

**当登录成功后，保存当前时间戳（登录时的时间戳）到本地存储，然后在 axios 二次封装的 request.js 文件中，定义一个 Token 过期的时间，一般为三个小时，根据实际开发决定，最后封装一个判断是否超时的函数（ return  当前时间戳减去登陆时保存的时间戳/1000 > 过期时间 ），如果超时，返回 true，在请求拦截器中注入 Token 之前，也就是携带请求头 Token 之前，退出登录（包括清空 Vuex 中的 Token、本地存储的 Token、跳转到登录页），并且手动 reject 终止执行当前 axios 请求的父级函数（由于处理 Token 过期的操作是在请求拦截器中执行，也就是发送请求时执行，因此需要手动终止当前请求）**

##### （二）服务端被动介入

**当页面刷新或者切换页面时，会返回请求数据，如果 Token 过期，按照规范，后端会返回 401 Unauthorized 错误，因此可在响应拦截器中的 error 函数中，通过 error.response.status === 401 判断 Token 是否过期（如果后端返回的不是 401 错误，axios 则无法将该错误视为响应错误，需在响应拦截器中的 response 函数中进行单独判断处理），如果过期，退出登录（包括清空 Vuex 中的 Token、本地存储的 Token、跳转到登录页）**

**尤其注意：这里必须先删除Token，再进行退出操作，顺序不能反**

**补充：当 Token 过期，跳转登录页时，可以带上请求失效（检测到 Token 过期）所在页面的完整地址，当登录完成后，会自动回跳原先的页面（此操作又称为 Token 的有感刷新，也就是手动登录并回跳原来的页面，这个过程用户是可知的，只不过需要重复登陆，略微麻烦）**

```javascript
// 在 request.js 文件中，需额外引入 router
import router from "@/router";

router.push({
  path: '/login',
  // 在跳转登录页时，可以传递一个自定义参数（假设名为 returnUrl），里面保存的是跳转登录页之前的页面地址（固定写法）
  query: { 自定义参数: router.currentRoute.value.fullPath }
  // Vue2 中通过以下方式拿到当前路由的完整路径
  query: { 自定义参数: router.history.current.fullPath }
})
```

**在原来的登录功能基础上进行改造，当保存 token 后，先判断当前路由页面（登录页），有没有传递过来的自定义参数 returnUrl（保存的是路由地址），有的话跳转到该路由地址，否则跳转到首页**

```javascript
// 如果使用的是 TS，可能会类型错误，需要给 route.query.returnUrl 整体进行类型断言（as string）
this.$router.replace(this.$route.query.returnUrl || '/home')
```



#### 三十一、Token 无感刷新

**概念：通常在登录时，会返回一组 Token 值（包括 refresh_Token），短 Token 时效较短，一般为3小时左右，但是可以防止被盗用，安全性较高，长 Token（refresh_Token）时效较长，一般为15天左右，常用于短 Token 失效时，用于生成新的 " 短 Token "**

**结合《Token过期的解决方案（强制退出登录）》知识点，在响应拦截器中，通过 error.response 判断 Token 是否过期，如果过期，使用 refresh_Token（长 Token）作为请求头，并发送 axios 请求获取新的 ”短 Token“，然后在 Vuex 中重新保存 Token ，最后通过 return request ( error.config )  重新发送上一次由于 Token 失效导致失败的请求即可（此处的 return 可能需要，也可能不需要，视情况而定：是否需要执行 Promise.reject ( error ) 方法 ）**



#### 三十二、何时使用 try catch，何时不使用 try catch

**实际开发中，通常会使用 try catch 包裹 axios 请求，但这里需要注意的是，axios 本质是 promise 对象，当请求发生错误的时候，会触发请求拦截器或者响应拦截器内部的 error 函数（该函数主要是为了抛出 reject），使其进入到 promise 对象的 catch 中（并不是 try catch 中的 catch ），因此下一个 .then 无法继续执行（通俗理解就是 await 的下一条语句无法执行，因为它的父级函数终止），这也是阻塞的原因，但 promise 对象的 catch 只是在内部进行处理，不会外显，而 try catch 却是用于捕获异常，可以获取 promise 对象中 catch 的具体错误，并做其它操作，但如果在 promise 对象中 catch 里（具体指响应拦截器）已经做了消息提示等操作，可以不使用 try catch 再次进行包裹，但如果使用了，也仅仅是打印错误消息，便于测试，无需再次进行消息提示**

**简单来说，对 axios 进行封装的时候，如果做了消息提示等操作，在调用具体的请求方法时，就无需使用 try catch 包裹，当遇到非 axios 请求的 promise 对象，如一些组件库提供的方法，它们由于是 promise 对象，因此也可以使用 await 进行后续代码的阻塞，如果需要捕捉异常，则需要使用 try catch 包裹**



#### 三十三、element-ui 的 upload 组件搭配腾讯云上传文件

**（前提）下载 cos 腾讯云的 sdk 包：npm i cos-js-sdk-v5 --save**

1. **创建腾讯云储存桶，设置权限为 ” 公有读私有写 “，并在该存储桶的 ” 安全管理 “ 选项下的 ” 跨域访问CORS设置 “ 中添加规则，域名为公司提供的真实域名地址（开发时会提供测试域名地址），请求类型全部勾选即可**
2. **安装腾讯云官方的项目依赖：npm i cos-js-sdk-v5，用于指定上传的内容，以及上传到哪个储存桶（其中提供了获取上传进度的 API）**
3. **对 upload 组件样式进行调整（通过控制台调试样式，修改原本的 css，实现自定义），给 upload 组件添加一个 file-list 属性并绑定一个变量（数组形式，其中为对象），再手动通过 on-change 属性绑定的钩子函数，将选中的文件添加到 file-list 绑定的变量中，就可以显示本地选择的文件**
4. **其中 list-type 控制的是选择文件后在本地显示的样式（内置样式，可通过插槽自定义样式），action 是上传的请求地址，可能需要搭配请求头来使用，但是如果是自定义上传到腾讯云储存桶中，则需要将 action 设置一个 # 号，并使用 http-request 属性绑定的钩子函数覆盖默认的上传行为（该函数有一个params 参数，其中 params.file 可以获取当前需要上传到腾讯云服务器的文件）**
5. **当点击其中某一个已经显示在本地的文件时（当前已选择的文件中的某一个），会触发 on-preview 属性绑定的钩子函数，常用于实现图片预览功能，on-remove 属性绑定的钩子函数，用于删除某个当前已选择的文件，从 file-list 绑定的变量中删除该数据**
6. **使用 before-upload 属性绑定的钩子函数，可在文件上传前，做某些事，一般用于判断文件上传的格式，大小等**
7. **在 http-request 属性绑定的钩子函数中，书写以下代码（使用 cos 腾讯云的 sdk 提供的 API）：**

```javascript
// 引入 cos 腾讯云的 sdk
import COS from 'cos-js-sdk-v5'
// 基于 SecretId 和 SecretKey 创建实例
const cos = new COS({
    // 身份识别 ID
    SecretId: '此处 ID 由后端请求获取而来',
    // 身份密钥
    SecretKey: '此处 Key 由后端请求获取而来'
})

// http-request 绑定的钩子函数名为 upload
upload(params) {
  // 如果上传的文件存在，执行以下操作
  if (params.file) {
    // 显示进度条（准备一个进度条组件，开始上传时显示进度条）
    this.showPercent = true
    // 执行上传操作
    cos.putObject(
      {
        // 储存桶名称
        Bucket: 'shuiruohanyu-1302806742',
        // 地域
        Region: 'ap-beijing',
        // 上传的文件名
        Key: params.file.name,
        // 要上传的文件
        Body: params.file,
        StorageClass: 'STANDARD',
        // 实时获取上传进度的钩子函数
        onProgress: (params) => {
          // 给控制进度条百分比的变量，实时更新百分比的值
          this.percent = params.percent * 100
        }
      },
      (err, data) => {
        // data 中有一个 statusCode，等于 200 的时候说明上传成功
        if (!err && data.statusCode === 200) {
          // data.Location 是上传成功后返回的在线地址，替换选择本地文件时的临时 url 地址
          this.fileList = this.fileList.map((item) => {
            if (item.uid === params.file.uid) {
              // 将在线的地址赋值给原来的 url 属性，并记录一个成功状态（后续利用该状态提交表单，当为 true 表明上传完成，才能提交表单）
              return { url: 'http://' + data.Location, status: 'success' }
            }
            return item
          })
          // 关闭进度条，并将百分比重新设为 0
          setTimeout(() => {
            this.showPercent = false
            this.percent = 0
          }, 500)
        }
      }
    )
  }
}
```



#### 三十四、将数据转换成 element-ui 规定的树形结构

```javascript
// 预置知识: 如果B数据的 pid 等于A数据的 id，代表B是A的子级

// 封装一个转换成树形结构的方法，并按需导出
export function tranListToTreeData(list, rootValue) {
  var arr = []
  list.forEach((item) => {
    // 先找到根节点
    if (item.pid === rootValue) {
      // 找到之后，使用递归，去找 item 下面有没有子节点
      const children = tranListToTreeData(list, item.id)
      if (children.length) {
        // 如果 children 的长度大于0 说明找到了子节点
        item.children = children
      }
      arr.push(item) // 将内容加入到数组中
    }
  })
  return arr
}

// 调用该方法，传入源数据，并传入根级标识，一般为 “ ”（通常情况，pid 为 “ ” 就代表根节点，也就是根级标识）
需要保存的变量 = tranListToTreeData( 数据源, 根级标识 )
```



#### 三十五、监听本地存储的变化

**某些情况下，浏览器打开多个标签页，在其中一个标签页操作数据后，另一个标签页并不会更新视图，这就涉及到了跨标签页通信，正常情况下，一个标签页无法影响另一个标签页，因此可通过监听本地存储的变化，来更新视图**

1. **当执行增删改查操作时，手动将当前更改的数据（或与之相关的数据），保存在本地存储**

```javascript
// 利用 uuid 插件生成唯一标识符（需安装依赖：yarn add uuid@9.0.1，其它版本可能出现问题）
import { v4 as uuidv4 } from "uuid";

// 根据操作类型的不同（增删改查），保存此次操作变化的数据（操作类型作为键名，与当前操作相关的数据作为值）
const sendMsg = (operateType, data) => {
    localStorage.setItem(operateType, JSON.stringify({
        data,
        // 确保每次保存时，唯一标识符不同，始终都会触发保存的操作
        temp: uuidv4()
    }))
}
```

2. **在需要实时更新视图的页面，监听本地存储的变化（封装成方法）**

```javascript
// 监听本地存储变化的方法，当本地存储的某个特定项发生变化，执行某些操作
const listenMsg = (handlerFun) => {
    // 本地存储的监听的事件处理函数（单独抽离）
    const storageHandler = (e) => {
        // 调用传递进来的方法（该方法是需要执行的操作，在调用 listenMsg 方法时，单独定义内部的处理程序），并将本地存储发生变化的键和值作为该方法的参数
        handlerFun(e.key, JSON.parse(e.newValue).data)
    }
    // 监听本地存储
    window.addEventListener('storage', storageHandler)
    // 暴露一个移除该监听本地存储的方法
    return () => {
        window.removeEventListener('storage', storageHandler)
    }
}
```

3. **调用 listenMsg 方法，该方法接收的是一个回调函数，该回调函数内部的处理程序视情况自己定义，但该回调函数自身所接收的参数，第一个参数是本地存储中发生变化的键名，第二个参数是本地存储中发生变化的值，通过键和值执行某些操作**

```javascript
listenMsg((operateType, data) => {
    if (operateType === '本地存储中发生变化的键名') {
        // 依赖于data（本地存储中发生变化的值），执行增删改查操作，更新视图
    }
})
```



#### 三十六、Vue 中实现锚点滚动

**前提：封装一个锚点滚动的方法**

```javascript
// 锚点滚动的方法
const skip = (唯一标识符参数) => {
    document.querySelector('#' + 唯一标识符参数).scrollIntoView({
        behavior: "smooth"
    });
}
```

1. **对数据源进行 v-for 渲染的过程中，动态绑定 id，并绑定点击事件，id 的值和事件处理函数所需要的参数，都为当前循环项 item 中的唯一标识符**

```html
<组件标签名 v-for="(item,index) in 数据源" :id="item 中的唯一标识符" @click="事件处理函数(item 中的唯一标识符)"></组件标签名>
```

2. **事件处理函数中调用封装好的 skip 方法**

```javascript
事件处理函数(item 中的唯一标识符){
    // 调用skip方法
    skip(item 中的唯一标识符)
}
```



#### 三十七、轮播图、tabBar 切换动画、以及 Tab 菜单栏的小横线移动

**轮播图：父盒子固定宽高，子盒子超出父盒子宽度（子盒子设置 flex，并让里面的每一项与父盒子同宽，且设置 flex-shrink: 0），设定一个变量，默认值为 0，当切换轮播图时，改变该变量的值，让子盒子移动即可（使用动态 style，配合 transform：translateX：- 当前变量值 * 固定宽）**

**tabBar 切换动画：与轮播图类似，绝对定位一个遮罩层，通过设定的变量值，关联固定宽计算出 left 的值（或者直接使用事件对象获取当前被点击元素相对于最左边的距离（offsetLeft），最后搭配动态 style 给 left 赋值即可**

**Tab 菜单栏的小横线移动（横线的长短可变化）：与tabBar 切换动画类似，绝对定位一个小横线，通过事件对象，获取当前被点击元素的 offsetLeft 和 offsetWidth 值，最后配合动态类名，给小横线的 left 和 width 进行赋值即可**



#### 三十八、v-model 双向绑定 vuex 中的数据

**由于 vuex 的数据可以单向获取，修改需要通过 vuex 中单独的方法进行修改，因此无法使用 v-model 直接绑定 vuex 中的数据，需要配合计算属性**

**使用步骤：定义一个计算属性，使用 v-model 绑定该计算属性名称即可**

```javascript
  computed: {
    计算属性名称: {
      set(val) {
          通过 vuex 中定义的方法，修改数据的值为 val
      },
      get() {
        return 正常从 vuex 中获取数据
      }
    }
  }
```



#### 三十九、利用 scss 混入实现主题切换

1. **在 veux 中定义一个 state 数据，名为 theme，默认值为 light**
2. **当点击切换主题的按钮时，修改 vuex 中 theme 数据的值**
3. **在 App 根组件中，使用侦听器，侦听 vuex 中 theme 的改变，当 theme 改变时，给 html 设置自定义属性（data-theme），值为 vuex 当前 theme 值**

```javascript
// vue2 中的写法
watch: {
  "vuex中的theme数据": {
    handler(newVal) {
      window.document.documentElement.setAttribute("data-theme", vuex中当前的theme值);
    },
    immediate: true,
  },
}
    
// vue3 中的写法
watch(vuex中的theme数据, (newVal) => {
    window.document.documentElement.setAttribute('data-theme', vuex中当前的theme值)
},{immediate: true})
```

4. **在 styles 文件夹下新建 theme 文件夹，其中包含两个文件，variable.scss 和 mixin.scss，前者用于定义所有主题色，后者是用于定义混合器**

**（Ⅰ）在 variable.scss 中定义多个主题（此处以白色、暗黑主题为例），每个主题下自定义键名，以及键名对应的值（颜色居多）**

```scss
// 注意：自定义键名的值如果重复性高，也可抽离成一个单独的变量
$themes:(
    // 尤其注意：多套主题，自定义键名必须保持完全一致
    light:(
        自定义键名:值,
        // 以下为举例，自定义键名的取名要见名知意
        btn_bg_color:#e7e7e7,
        font_size:14px,
        font_color:rgba(0,0,0,0.9),
        background_color:#fff,
        border_color:#dcdcdc,
    ),
    dark:(
        自定义键名:值,
        // 以下为举例，自定义键名的取名要见名知意
        btn_bg_color:#383838,
        font_size:14px,
        font_color:#fff,
        background_color:#242424,
        border_color:#383838,
    )
);
```

**（Ⅱ）在 mixin.scss 中定义混合器，当别的地方调用该混合器，会生成多套主题的样式代码（当 html 的自定义属性值变化，对应的主题样式代码生效）**

```scss
// 首先引入存放所有主题的样式文件
@import "./variable";

@mixin themeify() {
  @each $theme-name,
  $theme-map in $themes {
    $theme-map: $theme-map !global;
    [data-theme="#{$theme-name}"] & {
      @content;
    }
  }
}

@function themed($key) {
  @return map-get($theme-map, $key);
}
```

5. **在 styles 文件夹下新建一个 global.scss 文件，该文件用于定义全局样式，可对统一需要更换主题色的类名，通过调用 themeify 这个混合器，设定某些 css 属性的主题色，最后在 main.js 文件中引入 global.scss 即可**

```scss
// 在使用混入器的地方，需要引入 mixin.scss 文件
@import "mixin.scss 文件的位置";

// 使用 @include themeify 需要最外层有一个类名
.最外层的类名 {
    .需要更换主题色的类名（父级） {
        不需要设置的css属性: 属性值;
        // 每个需要设置的 css 属性都需要使用 @include themeify 进行包裹
        @include themeify {
            需要设置的css属性: themed("需要使用的主题中的自定义键名");
        }
        .需要更换主题色的类名（子级） {
            不需要设置的css属性: 属性值;
            // 每个需要设置的 css 属性都需要使用 @include themeify 进行包裹，同一级的 css 属性可一次性包裹
            @include themeify {
                需要设置的css属性: themed("需要使用的主题中的自定义键名");
                需要设置的css属性: themed("需要使用的主题中的自定义键名");
            }
        }
    }
}
```



#### 四十、利用 xslx 插件实现 excel 的导入功能

**excel 的导入功能，实际上就是点击上传 excel（并不是上传到服务器，而是模拟上传，实际上交给 xslx 插件解析 excel），并返回解析后的数据，最后按照业务需求对数据进行改造，改造成后端需要的请求参数格式**

1. **下载 xslx 依赖：npm i xslx（建议使用 npm 下载，yarn 可能会出现问题）**
2. **封装一个 excel 上传组件（所谓上传，其实就是导入功能），并全局注册（该组件无样式，按照业务需求自定义样式）**

```html
<template>
  <div>
    <!-- input不需要修改 -->
    <input
      ref="excel-upload-input"
      type="file"
      accept=".xlsx, .xls"
      @change="handleClick"
      hidden
    />

    <!-- 点击上传:可对点击上传的按钮进行自定义样式 -->
    <button @click="handleUpload">点击上传</button>

    <!-- 拖拽上传:可对拖动上传的盒子及图标进行自定义样式 -->
    <div
      @drop="handleDrop"
      @dragover="handleDragover"
      @dragenter="handleDragover"
    >
      <span>此处自定义图标</span>
      <span>拖拽上传</span>
    </div>
  </div>
</template>

<script>
import { read, utils } from "xlsx";
export default {
  props: {
    beforeUpload: Function,
    onSuccess: Function,
  },
  data() {
    return {
      loading: false,
      excelData: {
        header: null,
        results: null,
      },
    };
  },
  methods: {
    generateData({ header, results }) {
      this.excelData.header = header;
      this.excelData.results = results;
      this.onSuccess && this.onSuccess(this.excelData);
    },
    handleDrop(e) {
      e.stopPropagation();
      e.preventDefault();
      if (this.loading) return;
      const files = e.dataTransfer.files;
      if (files.length !== 1) {
        this.$message.error("Only support uploading one file!");
        return;
      }
      const rawFile = files[0];
      if (!this.isExcel(rawFile)) {
        this.$message.error(
          "Only supports upload .xlsx, .xls, .csv suffix files"
        );
        return false;
      }
      this.upload(rawFile);
      e.stopPropagation();
      e.preventDefault();
    },
    handleDragover(e) {
      e.stopPropagation();
      e.preventDefault();
      e.dataTransfer.dropEffect = "copy";
    },
    handleUpload() {
      this.$refs["excel-upload-input"].click();
    },
    handleClick(e) {
      const files = e.target.files;
      const rawFile = files[0];
      if (!rawFile) return;
      this.upload(rawFile);
    },
    upload(rawFile) {
      this.$refs["excel-upload-input"].value = null;
      if (!this.beforeUpload) {
        this.readerData(rawFile);
        return;
      }
      const before = this.beforeUpload(rawFile);
      if (before) {
        this.readerData(rawFile);
      }
    },
    readerData(rawFile) {
      this.loading = true;
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const data = e.target.result;
          const workbook = read(data, { type: "array" });
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];
          const header = this.getHeaderRow(worksheet);
          const results = utils.sheet_to_json(worksheet);
          this.generateData({ header, results });
          this.loading = false;
          resolve();
        };
        reader.readAsArrayBuffer(rawFile);
      });
    },
    getHeaderRow(sheet) {
      const headers = [];
      const range = utils.decode_range(sheet["!ref"]);
      let C;
      const R = range.s.r;
      for (C = range.s.c; C <= range.e.c; ++C) {
        const cell = sheet[utils.encode_cell({ c: C, r: R })];
        let hdr = "UNKNOWN " + C;
        if (cell && cell.t) hdr = utils.format_cell(cell);
        headers.push(hdr);
      }
      return headers;
    },
    isExcel(file) {
      return /\.(xlsx|xls|csv)$/.test(file.name);
    },
  },
};
</script>

<style lang="scss" scoped></style>
```

3. **使用该组件时（组件取名为：excelUpload），可以在组件上使用 onSuccess 属性绑定的方法和 beforeUpload 属性绑定的方法**

```html
<ExcelUpload
  :onSuccess="onSuccess"
  :beforeUpload="beforeUpload"
></ExcelUpload>
```

4. **beforeUpload 属性绑定的方法用于上传之前做一些判断（如文件格式、大小），如果判断通过一定要返回 true**

```javascript
beforeUpload(rawFile) {
  // rawFile 是上传之前捕获到的文件信息，当判断通过后，一定要返回 true
  return true
},
```

5. **onSuccess 属性绑定的方法会在上传成功后返回对 excel 解析后的数据，可以按照实际业务需求，对返回的数据进行二次改造**

```javascript
onSuccess({ header, results }) {
  console.log("解析后的表头数据", header);
  console.log("解析后的表格数据", results);

  // 由于返回的 results 数据中，每个对象的键名是中文形式（来源于中文的表头）,需要转换成后端规定的单词(通常是英文)
  // 假设返回数据中每个对象有四个中文键名,应设置中文键名的对应关系
  const keyMap = {
    中文键名1: "需要转换的单词",
    中文键名2: "需要转换的单词",
    中文键名3: "需要转换的单词",
    中文键名4: "需要转换的单词",
  };

  const newResults = results.map((item) => {
    const obj = {};
    Object.keys(keyMap).forEach((key) => {
      obj[keyMap[key]] = item[key];
    });
    return obj;
  });

  // 利用 newResults 发送后端请求
  console.log(newResults);
},
```



#### 四十一、js 文件的懒加载

**通常情况，在某个 Vue 组件中，引入 js 文件，并按需导出其中的方法，无论有没有通过点击某个按钮或者其它操作调用其中的方法，js 文件都被加载了，针对性能优化，可让该 js 文件实现懒加载，只有调用了该 js 文件中的方法，才加载 js 文件**

1. **下载 js 文件懒加载的插件：npm install script-loader -S -D**
2. **在 js 文件中定义的每一个方法，必须要按需导出，而不能默认导出**
3. **使用该 js 文件中的方法，使用如下语法：**

```javascript
import("当前 js 文件的路径").then((result) => {
  // 该方法会把当前 js 文件里所有按需导出的方法，包装成一个对象，result 就是这个对象，通过 “ result.方法 ” 进行使用
});
```



#### 四十二、利用 xslx 插件实现 excel 的导出功能

**excel 的导出功能，实际上就是将当前数据（在后台管理系统中，通常是当前页的数据，或者是所有数据，所有数据需要一般是通过接口获取，但如果后端不提供获取所有数据的接口，只提供分页数据的接口，则需要利用参数，通过第一页获取所有的数据）转换成 excel 文件**

1. **下载 xslx 依赖（excel 导入功能使用了该插件，已下载过，则无需下载），并且下载 file-saver 依赖：npm install xlsx file-saver**
2. **excel 的导出功能，被封装在一个单独 js 文件中，由于该 js 文件较大，建议使用 js 文件懒加载方式调用里面的方法：npm install script-loader -S -D**
3. **在 src 下新建一个 excelExport 文件夹，并存放 Export2Excel.js 文件**
4. **Export2Excel.js 代码如下，其中的 export_json_to_excel 方法就是依赖于后端请求返回的数据，将其转换并导出 excel 文件**

```javascript
import { saveAs } from "file-saver";
import { utils, SSF, write } from "xlsx";

function generateArray(table) {
  var out = [];
  var rows = table.querySelectorAll("tr");
  var ranges = [];
  for (var R = 0; R < rows.length; ++R) {
    var outRow = [];
    var row = rows[R];
    var columns = row.querySelectorAll("td");
    for (var C = 0; C < columns.length; ++C) {
      var cell = columns[C];
      var colspan = cell.getAttribute("colspan");
      var rowspan = cell.getAttribute("rowspan");
      var cellValue = cell.innerText;
      if (cellValue !== "" && cellValue == +cellValue) cellValue = +cellValue;

      //Skip ranges
      ranges.forEach(function (range) {
        if (
          R >= range.s.r &&
          R <= range.e.r &&
          outRow.length >= range.s.c &&
          outRow.length <= range.e.c
        ) {
          for (var i = 0; i <= range.e.c - range.s.c; ++i) outRow.push(null);
        }
      });

      //Handle Row Span
      if (rowspan || colspan) {
        rowspan = rowspan || 1;
        colspan = colspan || 1;
        ranges.push({
          s: {
            r: R,
            c: outRow.length,
          },
          e: {
            r: R + rowspan - 1,
            c: outRow.length + colspan - 1,
          },
        });
      }

      //Handle Value
      outRow.push(cellValue !== "" ? cellValue : null);

      //Handle Colspan
      if (colspan) for (var k = 0; k < colspan - 1; ++k) outRow.push(null);
    }
    out.push(outRow);
  }
  return [out, ranges];
}

function datenum(v, date1904) {
  if (date1904) v += 1462;
  var epoch = Date.parse(v);
  return (epoch - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);
}

function sheet_from_array_of_arrays(data, opts) {
  var ws = {};
  var range = {
    s: {
      c: 10000000,
      r: 10000000,
    },
    e: {
      c: 0,
      r: 0,
    },
  };
  for (var R = 0; R != data.length; ++R) {
    for (var C = 0; C != data[R].length; ++C) {
      if (range.s.r > R) range.s.r = R;
      if (range.s.c > C) range.s.c = C;
      if (range.e.r < R) range.e.r = R;
      if (range.e.c < C) range.e.c = C;
      var cell = {
        v: data[R][C],
      };
      if (cell.v == null) continue;
      var cell_ref = utils.encode_cell({
        c: C,
        r: R,
      });

      if (typeof cell.v === "number") cell.t = "n";
      else if (typeof cell.v === "boolean") cell.t = "b";
      else if (cell.v instanceof Date) {
        cell.t = "n";
        cell.z = SSF._table[14];
        cell.v = datenum(cell.v);
      } else cell.t = "s";

      ws[cell_ref] = cell;
    }
  }
  if (range.s.c < 10000000) ws["!ref"] = utils.encode_range(range);
  return ws;
}

function Workbook() {
  if (!(this instanceof Workbook)) return new Workbook();
  this.SheetNames = [];
  this.Sheets = {};
}

function s2ab(s) {
  var buf = new ArrayBuffer(s.length);
  var view = new Uint8Array(buf);
  for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) & 0xff;
  return buf;
}

export function export_table_to_excel(id) {
  var theTable = document.getElementById(id);
  var oo = generateArray(theTable);
  var ranges = oo[1];

  /* original data */
  var data = oo[0];
  var ws_name = "SheetJS";

  var wb = new Workbook(),
    ws = sheet_from_array_of_arrays(data);

  /* add ranges to worksheet */
  // ws['!cols'] = ['apple', 'banan'];
  ws["!merges"] = ranges;

  /* add worksheet to workbook */
  wb.SheetNames.push(ws_name);
  wb.Sheets[ws_name] = ws;

  var wbout = write(wb, {
    bookType: "xlsx",
    bookSST: false,
    type: "binary",
  });

  saveAs(
    new Blob([s2ab(wbout)], {
      type: "application/octet-stream",
    }),
    "test.xlsx"
  );
}

export function export_json_to_excel({
  multiHeader = [],
  header,
  data,
  filename,
  merges = [],
  autoWidth = true,
  bookType = "xlsx",
} = {}) {
  /* original data */
  filename = filename || "excel-list";
  data = [...data];
  data.unshift(header);

  for (let i = multiHeader.length - 1; i > -1; i--) {
    data.unshift(multiHeader[i]);
  }

  var ws_name = "SheetJS";
  var wb = new Workbook(),
    ws = sheet_from_array_of_arrays(data);

  if (merges.length > 0) {
    if (!ws["!merges"]) ws["!merges"] = [];
    merges.forEach((item) => {
      ws["!merges"].push(utils.decode_range(item));
    });
  }

  if (autoWidth) {
    /*设置worksheet每列的最大宽度*/
    const colWidth = data.map((row) =>
      row.map((val) => {
        /*先判断是否为null/undefined*/
        if (val == null) {
          return {
            wch: 10,
          };
        } else if (val.toString().charCodeAt(0) > 255) {
        /*再判断是否为中文*/
          return {
            wch: val.toString().length * 2,
          };
        } else {
          return {
            wch: val.toString().length,
          };
        }
      })
    );
    /*以第一行为初始值*/
    let result = colWidth[0];
    for (let i = 1; i < colWidth.length; i++) {
      for (let j = 0; j < colWidth[i].length; j++) {
        if (result[j]["wch"] < colWidth[i][j]["wch"]) {
          result[j]["wch"] = colWidth[i][j]["wch"];
        }
      }
    }
    ws["!cols"] = result;
  }

  /* add worksheet to workbook */
  wb.SheetNames.push(ws_name);
  wb.Sheets[ws_name] = ws;

  var wbout = write(wb, {
    bookType: bookType,
    bookSST: false,
    type: "binary",
  });
  saveAs(
    new Blob([s2ab(wbout)], {
      type: "application/octet-stream",
    }),
    `${filename}.${bookType}`
  );
}
```

5. **给导出按钮绑定点击事件，在事件函数中，以 js 文件懒加载的形式，使用 export_json_to_excel 方法，但是由于用户想要的导出后的 excel 表格顺序（姓名、年龄、性别）与后端请求返回的数据（姓名、性别、年龄）顺序不一致，因此需要对原数据进行改造，再使用 export_json_to_excel 方法**

```javascript
// 假设导出按钮绑定的事件函数名为 excelExport
excelExport() {
  // 使用 js 文件懒加载
  import("Export2Excel.js 文件所在的路径").then((excel) => {
    // 此处可发送请求获取数据，并改造数据
    // 假设后端返回的数据为 data，数组形式，里面每个对象中的属性为 name，sex，age，如果直接以此循环遍历改造，顺序与用户想要的导出后的 excel 表格顺序不一致，因此需要设置中文对应关系（保存在 mapKey），以 mapKey 作为循环依据，就可以实现顺序的可控、可自定义
    const mapKey = {
      姓名: 'name',
      年龄: 'age',
      入职日期: 'timeOfEntry'
    }
    // 将原数据 data 改造成 excel 主体内容数据（newData）
    const newData = data.map((item) => {
      return Object.keys(mapKey).map((key) => {
        return item[mapKey[key]];
    })

    // 调用 export_json_to_excel 方法
    excel.export_json_to_excel({
      // 表头（第一行），数组形式，实际开发中将 Object.keys(mapKey) 作为表头即可
      header: ["姓名", "年龄", "性别"],
      // excel 主体内容，二维数组形式，里面每一个数组代表一行数据（将后端请求返回的数据改造成如下格式即可），实际开发中将 newData 作为主体内容即可
      data: [
        ["张三", "24", "男"],
        ["李四", "28", "男"],
        其它数组...
      ],
      filename: "导出的文件名称",
      // 单元格是否要自适应宽度（默认为 true，该属性配置可忽略不写）
      autoWidth: true,
      // 导出的文件类型（默认为 xlsx，该属性配置可忽略不写）
      bookType: "xlsx",
      // 在表头（第一行）前面，可新增多行，二维数组形式，里面每一个数组代表一行数据
      multiHeader: [["姓名", "主要信息", ""]，其它数组...],
      // 合并行或列（A1 和 A2合并，B1 和 B3合并）
      merges: ["A1:A2", "B1:B3"],
    });
  });
}
```

**补充：如果 excel 导出功能，不需要前端去处理相关逻辑，而是由后端（服务端）进行处理，前端只需要在点击 “ 导出 excel ” 按钮后，调用请求接口即可，该接口会以二进制文件流的形式返回一个 excel 文件数据，针对这种特殊的接口，在封装请求方法时，需要新增一个参数 responseType: 'blob'，用于指定该请求返回数据的类型，使用 blob 接收二进制文件流，最后需要对请求接口返回的数据，也就是返回的二进制文件流数据进行处理，将其转变为真正的 excel 文件**

1. **封装请求方法时，指定返回数据的类型为二进制文件流（blob）**

```javascript
export const 请求函数名 = () => {
  return request({
    url: "请求地址",
    responseType: 'blob'
  })
}
```

2. **调用该请求后，得到返回的结果（二进制文件流形式，也就是 blob 对象），需要使用 file-saver 依赖包提供的方法，将其下载到本地**

```javascript
import { saveAs } from "file-saver";

// 使用 saveAs 方法，将请求返回的结果（blob 对象）下载到本地
saveAs (请求返回的结果，'自定义名称.xlsx')
```

3. **如果在封装 axios 请求时，对响应拦截器中返回的数据进行了解构处理，并返回真正想要的数据（只针对请求返回的是 json 数据的情况），在调用该接口时，会导致报错，因为 response.data 如果返回的是非 json 数据，而是 blob 文件，无法解构，在响应拦截器中，需要添加一个额外条件**

```javascript
// 当返回数据为 blob 文件，返回 response.data（只剥离 axios 自己包装的那一层即可）
if (response.data instanceof Blob) return response.data
```



#### 四十三、数字滚动插件

1. **下载依赖：npm i vue-count-to**

2. **使用：`<count-to :start-val="0" :end-val="真正的数据" :duration="1000" :decimals="保留的小数位数" />`**



#### 四十四、富文本编辑器插件

1. **下载依赖：npm install vue-quill-editor --save**

2. **在 main.js 文件中引入相关样式，并全局注册成组件**

```javascript
import VueQuillEditor from 'vue-quill-editor'
 
import 'quill/dist/quill.core.css'
import 'quill/dist/quill.snow.css'
import 'quill/dist/quill.bubble.css'
 
Vue.use(VueQuillEditor)
```

3. **在 vue 页面中使用该组件即可，可直接绑定 v-model（详细配置可参考文档）**

**尤其注意：如果是配合 element 的表单使用，由于该富文本编辑器不属于 element 表单组件，无法通过内置校验规则自动触发校验，需要使用对表单部分校验的方法，手动触发校验**



#### 四十五、Vue 中 Echarts 的使用

1. **安装 echarts 依赖：npm install echarts --save**
2. **在 view 文件夹中，某个页面级文件夹下，新建 chart 文件夹，将每一个 Echarts 图表，单独抽离出来并封装成图表组件**
3. **在每一个图表组件中，按需引入 echarts（性能优化）**

```javascript
// 引入 echarts 核心模块，核心模块提供了 echarts 使用必须要的接口
import * as echarts from 'echarts/core';
// 按照实际开发需求，引入柱状图、折线图、饼图、散点图中的其中一个
import { BarChart, LineChart, PieChart, ScatterChart } from 'echarts/charts';
// 按照实际开发需求，引入提示框、标题、直角坐标系、数据集、内置数据转换器组件中的其中部分组件
import {
  TitleComponent,
  TooltipComponent,
  GridComponent,
  DatasetComponent,
  TransformComponent
} from 'echarts/components';
// 标签自动布局、全局过渡动画等特性（可省略，非必要特性）
import { LabelLayout, UniversalTransition } from 'echarts/features';
// 引入 Canvas 渲染器（此步骤为必须，不可省略）
import { CanvasRenderer } from 'echarts/renderers';

// 注册上面使用到的组件（此处为作展示，对所有组件进行了全部注册）
echarts.use([
  BarChart,
  LineChart,
  PieChart,
  ScatterChart,
  TitleComponent,
  TooltipComponent,
  GridComponent,
  DatasetComponent,
  TransformComponent,
  LabelLayout,
  UniversalTransition,
  CanvasRenderer
]);
```

4. **准备容器（每个图表组件就是一个图表，因此选择根标签作为容器即可），设置宽、高为 100%，并且给该容器绑定 ref 名称（假设为 chart）**
5. **在 mounted 钩子函数中初始化 echarts 实例**

```javascript
mounted(){
    this.myChart = echarts.init(this.$refs.chart)
}
```

6. **接收一个 props 数据（option），该数据可具有默认值，也就是默认配置，外部使用该图表组件时，可传递相关数据（通过请求获取），子组件监听该数据，当数据发生变化时，利用 this.myChart.setOption(option) 设置配置**
7. **在组件销毁时（destroyed 钩子函数中），通过 echarts.dispose() 方法销毁 echarts 方法生成的所有实例**

**补充：关于配置项的常用属性设置**

**（Ⅰ）柱状图：**

```javascript
    // 柱状图的配置项
    let option = {
      // （一）通用配置之标题配置
      title: {
        text: "标题名称",
        // 标题样式
        textStyle: {
          color: "red",
        },
      },

      // （二）通用配置之提示组件配置（鼠标悬浮在柱状图上显示的提示）
      tooltip: {
        // 触发时机
        trigger: "axis",
        // 自定义提示内容（分别代表系列名称、类名名称、类目名称对应的值）
        formatter: "使用 {a}、{b}、{c}，来自定义提示内容",
        // 实际开发中，formatter: "使用 {a}、{b}、{c}，来自定义提示内容"，可能无法满足需求（使用该方式，会丢失前面的小图标），因此采用函数形式
        formatter: (params) => {
            // 最终要显示的模板内容
            let tooltipContent = ''
            // 遍历 params 数组
            params.forEach((param) => {
              // 系列名称
              const seriesName = param.seriesName
              // 类目名称对应的值
              const value = param.value
              // 生成小图标的 HTML
              const icon = `<span style="display:inline-block;width:10px;height:10px;background-color:${param.color};margin-right:5px;"></span>`
              // 拼接模板内容
              tooltipContent += `${icon}${seriesName}: ${value}<br/>`
            })
            // 返回最终要显示的模板内容
            return tooltipContent
          }
      },
      
      // （三）通用配置之图例配置（最上方的图例标识）
      legend: {
        // 此处要和系列名称一一对应（如果只有一种系列，图例只显示一个不美观，一般省略该配置，没必要显示）
        data: ['系列名称（如苹果）', '系列名称（如橘子）'],
        // 图例的形状
        icon:'rect'
      },

      // x 轴数据，需配置类型，限定 x 轴属于类目还是值（一般为类目），如果是横向显示柱状图，则 x 轴的类型为值，对于值类型而言，只需要定义类型即可
      xAxis: {
        // type 类型为 "category"，表示 x 轴为类目
        type: "category",
        // 类目数据：x 轴上对应的每一个类目名称
        data: ["类目名称1", "类目名称2", "类目名称3", "类目名称4", "类目名称5", "类目名称6", "类目名称7", "类目名称8"],
      },
      // y 轴数据，需配置类型，限定 y 轴属于类目还是值（一般为类目），如果是横向显示柱状图，则 y 轴的类型为类目，对于类目类型而言，需定义类目数据
      yAxis: {
        // type 类型为 "value"，表示 y 轴为值（尤其注意：每一个类目名称对应的值的数据，不在此处定义，而是在系列配置中定义）
        type: "value",
        // 给 y 轴设置一个轴名称
        name: "y轴的名称",
        // 配置 y 轴刻度值（标注）
        axisLabel: {
          // 刻度值样式
          textStyle: {
            color: "刻度值的颜色"
          },
          // 格式化刻度值显示内容
          formatter: (value) => {
            // 此处根据 value 设置刻度值的显示内容，如 1000000 改成 100万
          }
        },
        // 配置 y 轴刻度线
        splitLine: {
          lineStyle: {
            color: '刻度线颜色',
            // 刻度线类型（虚线）
            type: 'dashed'
          }
        }
      },
        
      // 设置布局，若 y 轴刻度内容显示不下，可设置偏移，使整体布局右移
      grid: {
        left: 45
      },
      
      // x 轴内容显示不下，可设置横向滚动条
      dataZoom: [
        {
          type: "slider",
          show: true,
          // 滚动条组件的背景颜色
          backgroundColor: "rgb(19, 63, 100)",
          // 滚动条组件选中范围的填充颜色
          fillerColor: "rgb(16, 171, 198)",
          // 滚动条组件的边框颜色
          borderColor: "rgb(19, 63, 100)",
          // 是否显示 detail，即拖拽时候显示详细数值信息
          showDetail: false,
          startValue: 0,
          endValue: 5,
          filterMode: "empty",
          // 滚动条组件的宽度
          width: "50%",
          // 滚动条组件的显示位置
          height: 8,
          left: "center",
          // 是否锁定选择区域（又称数据窗口）的大小
          zoomLoxk: true,
          // 控制滑块的尺寸
          handleSize: 0,
          // 滚动条组件距离容器下侧的距离
          bottom: 3,
        },
        {
          // 鼠标滚轮在区域内可控制外部滚动条
          type: "inside",
          // 滚轮是否触发缩放
          zoomOnMouseWheel: false,
          // 鼠标滚轮触发滚动
          moveOnMouseMove: true,
          moveOnMouseWheel: true,
        },
      ],

      // 系列配置
      series: [
        // 一个系列代表一个种类的数据（如苹果这个种类），如果图表需要显示多个系列（多个种类的柱状），增加一份系列即可（如橘子这个种类）
        {
          // 图表类型
          type: "bar",
          // 系列名称
          name: "系列名称（如苹果）",
          // 标注点配置
          markPoint: {
            data: [
              { name: "最大值", type: "max" },
              { name: "最小值", type: "min" },
            ],
          },
          // 标注线配置
          markLine: {
            data: [{ name: "平均值", type: "average" }],
          },
          // 标注配置（非悬浮在柱状图显示的提示，而是直接显示的标注，注意区分）
          label: {
            // 是否显示标注
            show: true,
            // 自定义标注内容
            formatter: '{a}{b}{c}',
            // 标注位置
            position: "top",
          },
          // 该系列柱状图的柱状宽度
          barWidth: "50%",
          // 该系列柱状图，显示在 y 轴上的一组数据（分别与每一个类目名称对应的值）
          data: [88, 92, 63, 77, 94, 80, 72, 86],
        }
      ],
    };
```



#### 四十六、根据权限点控制功能权限

1. **封装 permission 指令**

```javascript
Vue.directive('permission', {
  inserted(el, options) {
      // 从 vuex 中获取用户所拥有的权限点
      const points = vuex中保存的权限点数组
      // 如果用户所拥有的权限中不包含绑定元素传递过来的权限标识
      if(!points.includes(options.value)){
          // 移除该元素
          el.remove()
      }
  }
})
```

2. **给需要控制功能权限的元素（组件）绑定该指令，并传递该组件唯一权限标识（与后端统一固定、写死的标识符）**

```html
<组件标签名 v-permission = "该组件唯一权限标识符（字符串）" />
```



#### 四十七、侧边栏菜单和标签导航的联动

**侧边栏菜单的数据来源于路由数据（或者后端返回的菜单数据），标签导航的的数据则来源于，对路由的实时监听，当访问某个路由时，将当前路由数据改造成适用于标签导航数据的某一项，并追加进标签导航数据（需要判断该标签导航数据中是否存在该路由数据，若存在，则不追加）**

**当通过侧边栏菜单切换路由时，标签导航的对应项高亮，也是依赖于当前路由的数据（在监听的过程中，一般将当前路由路径作为高亮的依据，也就是将 active 设置为当前路由的路径即可），渲染标签导航的时候，再通过判断当前 active 是否等于当前标签导航项对应数据的某个属性，来决定是否显示高亮（注意：此时标签导航的点击事件中，无需再手动设置 active 的值，只需跳转路由即可，当路由跳转变化后，路由监听会自动改变 active 的值）**

**侧边栏菜单同理，当通过标签导航切换路由时，侧边栏菜单的对应项高亮，也是对路由进行监听，改变 active 的值即可（注意：此时侧边栏菜单的点击事件中，无需再手动设置 active 的值，只需跳转路由即可，当路由跳转变化后，路由监听会自动改变 active 的值）**



#### 四十八、利用 scss 混入实现媒体查询响应式布局

1. **在 styles 文件夹下新建 media.scss 文件，并写入以下代码：**

```scss
// 定义对象（又称断点名称），保存不同设备所对应的尺寸范围
$breakpoints: (
  // 备注：对象是('键名':值,'键名':值)，数组是(值, 值)
  'phone': (320px, 480px),
  'pad': (481px, 768px),
  'notebook': (769px, 1024px),
  'desktop': (1025px, 1200px),
  'tv': 1201px
);

// 媒体查询的混入器，要求传入 $breakname(设备名称)
@mixin respond-to($breakname) {
  // 根据设备名称查找对应尺寸范围
  $bp: map-get($breakpoints, $breakname);

  // 判断是否为数组，如果是 list，就是数组
  @if type-of($bp) == 'list' {
    // scss 中对数组进行取值
    $min: nth($bp, 1);
    $max: nth($bp, 2);

    @media (min-width: $min) and (max-width: $max) {
      // 插槽，接收传递过来的样式
      @content;
    }
  } @else {
    @media (min-width: $bp) {
      @content;
    }
  }
}
```

2. **在需要使用媒体查询实现响应式布局的地方，引入上述文件，使用混入器，定义不同设备下的样式**

```scss
.类名选择器 {
  @include respond-to('设备名称') {
      自定义样式
  }
}
```



#### 四十九、Vue 2 中的图片懒加载

1. **下载图片懒加载插件：yarn add vue-lazyload@1.3.3**
2. **在 main.js 中书写以下代码：**

```javascript
import VueLazyload from 'vue-lazyload'

Vue.use(VueLazyload, {
  preLoad: 1.3,
  attempt: 1,
  adapter: {
    loaded({ bindType, el, naturalHeight, naturalWidth, $parent, src, loading, error, Init }) {
      el.style.background = 'unset'
    },
    error({ bindType, el, naturalHeight, naturalWidth, $parent, src, loading, error, Init }) {
      // 若想延长加载的动画，可在显示错误图片的外层嵌套一层延时器（看情况添加）
      el.style.background = `${el.dataset.bg || "#fff"} no-repeat center / 100% url(${错误的图片路径，注意需要模块化引入本地静态资源})`
    },
    loading({ bindType, el, naturalHeight, naturalWidth, $parent, src, loading, error, Init }) {
      el.style.background = `#fff no-repeat center/30px url(${加载中的图片路径，注意需要模块化引入本地静态资源})`
    }
  }
})
```

**补充：一般静态资源，通常新建一个 js 文件，然后采取统一导出的方式，在需要使用的地方，默认导入并使用**

```javascript
export default {
  // 加载中的图片
  loading: require('../assets/images/common/loading.gif'),
  // 错误的图片
  error: require('../assets/images/common/error.svg')
}
```

3. **在 img 标签上，直接使用 v-lazy="真正的图片地址" 即可**
4. **如需自定义加载错误图片时的背景色，在 img 标签上增加 data-bg 属性并设置需要的颜色，然后在 main.js 懒加载核心代码处使用 el.dataset.bg 获取即可**



#### 五十、通过方法调用全局组件（适用于弹窗）

1. **创建一个弹窗组件，弹窗组件本身具有显示隐藏的方法，并在同目录下新建同名的 js 文件，然后书写以下内容：**

```javascript
import Vue from 'vue'
import 组件名 from '组件所在路径'

// 通过 extend 方法生成组件构造器
const 组件构造器 = Vue.extend(组件名)
// 实例化组件构造器，拿到组件实例，效果类似于 ref，可直接通过组件实例调用该组件内部的方法
const 组件实例 = new 组件构造器().$mount()

const 方法名 = (参数) => {
    // 将组件的 DOM 元素插入到 body 中（每次调用该方法时都会插入新的 DOM 元素，因此需要在关闭组件时，移除该 DOM 元素）
    document.body.appendChild(组件实例.$el)
    // 调用组件实例中的方法（如 show 方法，使弹窗显示）
    组件实例.show()
    // 利用调用该方法传递过来的参数做其它事情
    
    // 若干秒后，隐藏该组件
    setTimeout(() => {
        组件实例.hide()
        // 尤其注意：当关闭组件时，需要移除该组件的 DOM 元素
        组件实例.$el.parentNode.removeChild(组件实例.$el)
    }, 若干秒)
}
```

2. **在上述代码末尾，利用 vue 插件语法，进行全局挂载，最后再默认导出**

```javascript
export default {
    install(Vue){
        Vue.prototype.$自定义全局方法名称 = 方法名
    }
}
```

3. **在入口文件 main.js 中，默认导入该文件，通过 Vue.use ( 文件名 ) 进行插件安装，即可利用 `this.$自定义全局方法名称` 全局调用该组件**



#### 五十一、直播流组件封装

**概念：后端返回的是直播流地址，播放器的 url 换成直播流地址即可，难点在于，如何让播放器支持该直播流地址，且兼容，并且降低延迟**

##### （一）flv 直播流

1. **下载依赖：yarn add flv-extend -S**
2. **新建全局组件 Http-flv.vue，并书写以下代码，最后进行全局注册**

```vue
<template>
  <div class="Http-flv">
    <video
      class="video-player"
      ref="videoPlayer"
      controls
      muted
      autoplay
      controlslist="nodownload noremoteplayback"
    ></video>
  </div>
</template>

<script>
import FlvExtend from "flv-extend";

export default {
  props: {
    // 直播流地址
    liveStreamUrl: {
      type: String,
      default: "",
    },
  },
  data() {
    return {
      player: null,
    };
  },
  methods: {
    init(url) {
      // 每次创建实例前，如果 player 实例存在，销毁
      if (this.player) {
        this.player.close();
      }
      // 当前 video 标签
      const videoRef = this.$refs.videoPlayer;

      // 配置需要的功能
      const flv = new FlvExtend({
        element: videoRef, // 必传
        frameTracking: true, // 开启追帧设置
        updateOnStart: true, // 点击播放后更新视频
        updateOnFocus: true, // 获得焦点后更新视频
        reconnect: true, // 开启断流重连
        reconnectInterval: 10000, // 断流重连间隔
      });

      // 播放期间由于任何原因发生错误时触发
      flv.onError = (errObj, player) => {
        console.log("播放期间由于任何原因发生错误时触发：", errObj);
      };

      // 播放期间由于断流进行重连后触发
      flv.onReconnect = (reconnectObj, player) => {
        console.log("检测到断流，正在重连：", reconnectObj);
      };

      //  连续 3 帧无变化，视为卡住，自定义处理
      flv.onStuck = (player) => {
        console.log("连续 3 帧无变化，视为卡住，请自定义处理");
      };

      // 调用 init 方法初始化视频
      // init 方法的参数与 flvjs.createPlayer 相同，并返回 flvjs.player 实例
      this.player = flv.init(
        {
          type: "flv",
          url,
          isLive: true,
        },
        {
          enableStashBuffer: false, // 如果您需要实时（最小延迟）来进行实时流播放，则设置为false
          autoCleanupSourceBuffer: true, // 对SourceBuffer进行自动清理
          stashInitialSize: 128, // 减少首帧显示等待时长
          enableWorker: true, // 启用分离的线程进行转换
        }
      );

      // 直接调用play即可播放
      this.player.play();
    },
  },
  watch: {
    // 监听直播流地址
    liveStreamUrl: {
      handler(newVal, oldVal) {
        // 初始化加载直播流
        if (newVal && newVal !== oldVal) {
          this.$nextTick(() => {
            // 连接地址（开发环境地址 || 正式上线环境地址）
            let url;
            if (newVal.includes("http")) {
              url = newVal;
            } else {
              // 此处需要在 .env.development 文件中配置后端的 host 地址
              const host =
                process.env.VUE_APP_BACKEND_HOST || window.location.host;
              url = "http://" + host + newVal;
            }
            this.init(url);
          });
        }
      },
      immediate: true,
    },
  },
  beforeDestroy() {
    // 组件销毁前，销毁直播流
    this.player.close();
  },
};
</script>

<style lang="scss" scoped>
.Http-flv {
  height: 100%;
  overflow: hidden;
  .video-player {
    width: 100%;
    height: 100%;
    object-fit: fill;
  }
}
</style>
```

3. **在需要使用 flv 直播流的地方，使用该组件，并传入直播流地址即可：`<http-flv :liveStreamUrl="直播流地址"></http-flv>`**



##### （二）webRtc 直播流

1. **在 @/components 目录下新建 WebRtcLive 文件夹，并在其中新建 utils 文件夹，和 index.vue 文件，utils 文件夹中新建 jswebrtc.js 文件**
2. **在 jswebrtc.js 文件中，书写以下代码：**

```javascript
var JSWebrtc = {
  Player: null,
  VideoElement: null,
  CreateVideoElements: function () {
    const elements = document.querySelectorAll(".jswebrtc");
    for (let i = 0; i < elements.length; i++) {
      new JSWebrtc.VideoElement(elements[i]);
    }
  },
  FillQuery: function (query_string, obj) {
    obj.user_query = {};
    if (query_string.length == 0) return;
    if (query_string.indexOf("?") >= 0)
      query_string = query_string.split("?")[1];
    const queries = query_string.split("&");
    for (let i = 0; i < queries.length; i++) {
      const query = queries[i].split("=");
      obj[query[0]] = query[1];
      obj.user_query[query[0]] = query[1];
    }
    if (obj.domain) obj.vhost = obj.domain;
  },
  ParseUrl: function (rtmp_url) {
    const a = document.createElement("a");
    a.href = rtmp_url
      .replace("rtmp://", "http://")
      .replace("webrtc://", "http://")
      .replace("rtc://", "http://");
    let vhost = a.hostname;
    let app = a.pathname.substr(1, a.pathname.lastIndexOf("/") - 1);
    const stream = a.pathname.substr(a.pathname.lastIndexOf("/") + 1);
    app = app.replace("...vhost...", "?vhost=");
    if (app.indexOf("?") >= 0) {
      const params = app.substr(app.indexOf("?"));
      app = app.substr(0, app.indexOf("?"));
      if (params.indexOf("vhost=") > 0) {
        vhost = params.substr(params.indexOf("vhost=") + "vhost=".length);
        if (vhost.indexOf("&") > 0) {
          vhost = vhost.substr(0, vhost.indexOf("&"));
        }
      }
    }
    if (a.hostname == vhost) {
      const re = /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/;
      if (re.test(a.hostname)) vhost = "__defaultVhost__";
    }
    let schema = "rtmp";
    if (rtmp_url.indexOf("://") > 0)
      schema = rtmp_url.substr(0, rtmp_url.indexOf("://"));
    let port = a.port;
    if (!port) {
      if (schema === "http") {
        port = 80;
      } else if (schema === "https") {
        port = 443;
      } else if (schema === "rtmp") {
        port = 1935;
      } else if (schema === "webrtc" || schema === "rtc") {
        port = 1985;
      }
    }
    const ret = {
      url: rtmp_url,
      schema: schema,
      server: a.hostname,
      port: port,
      vhost: vhost,
      app: app,
      stream: stream,
    };
    JSWebrtc.FillQuery(a.search, ret);
    return ret;
  },
  HttpPost: function (url, data) {
    return new Promise(function (resolve, reject) {
      let xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
          const respone = JSON.parse(xhr.responseText);
          xhr.onreadystatechange = new Function();
          xhr = null;
          resolve(respone);
        }
      };
      xhr.open("POST", url, true);
      xhr.timeout = 5e3;
      xhr.responseType = "text";
      xhr.setRequestHeader("Content-Type", "application/json");
      xhr.send(data);
    });
  },
};
if (document.readyState === "complete") {
  JSWebrtc.CreateVideoElements();
} else {
  document.addEventListener("DOMContentLoaded", JSWebrtc.CreateVideoElements);
}
JSWebrtc.VideoElement = (function () {
  "use strict";
  var VideoElement = function (element) {
    const url = element.dataset.url;
    if (!url) {
      throw "VideoElement has no `data-url` attribute";
    }
    const addStyles = function (element, styles) {
      for (const name in styles) {
        element.style[name] = styles[name];
      }
    };
    this.container = element;
    addStyles(this.container, {
      display: "inline-block",
      position: "relative",
      minWidth: "80px",
      minHeight: "80px",
    });
    this.video = document.createElement("video");
    this.video.width = 960;
    this.video.height = 540;
    addStyles(this.video, { display: "block", width: "100%" });
    this.container.appendChild(this.video);
    this.playButton = document.createElement("div");
    this.playButton.innerHTML = VideoElement.PLAY_BUTTON;
    addStyles(this.playButton, {
      zIndex: 2,
      position: "absolute",
      top: "0",
      bottom: "0",
      left: "0",
      right: "0",
      maxWidth: "75px",
      maxHeight: "75px",
      margin: "auto",
      opacity: "0.7",
      cursor: "pointer",
    });
    this.container.appendChild(this.playButton);
    const options = { video: this.video };
    for (const option in element.dataset) {
      try {
        options[option] = JSON.parse(element.dataset[option]);
      } catch (err) {
        options[option] = element.dataset[option];
      }
    }
    this.player = new JSWebrtc.Player(url, options);
    element.playerInstance = this.player;
    if (options.poster && !options.autoplay) {
      options.decodeFirstFrame = false;
      this.poster = new Image();
      this.poster.src = options.poster;
      this.poster.addEventListener("load", this.posterLoaded);
      addStyles(this.poster, {
        display: "block",
        zIndex: 1,
        position: "absolute",
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
      });
      this.container.appendChild(this.poster);
    }
    if (!this.player.options.streaming) {
      this.container.addEventListener("click", this.onClick.bind(this));
    }
    if (options.autoplay) {
      this.playButton.style.display = "none";
    }
    if (this.player.audioOut && !this.player.audioOut.unlocked) {
      let unlockAudioElement = this.container;
      if (options.autoplay) {
        this.unmuteButton = document.createElement("div");
        this.unmuteButton.innerHTML = VideoElement.UNMUTE_BUTTON;
        addStyles(this.unmuteButton, {
          zIndex: 2,
          position: "absolute",
          bottom: "10px",
          right: "20px",
          width: "75px",
          height: "75px",
          margin: "auto",
          opacity: "0.7",
          cursor: "pointer",
        });
        this.container.appendChild(this.unmuteButton);
        unlockAudioElement = this.unmuteButton;
      }
      this.unlockAudioBound = this.onUnlockAudio.bind(this, unlockAudioElement);
      unlockAudioElement.addEventListener(
        "touchstart",
        this.unlockAudioBound,
        false
      );
      unlockAudioElement.addEventListener("click", this.unlockAudioBound, true);
    }
  };
  VideoElement.prototype.onUnlockAudio = function (element, ev) {
    if (this.unmuteButton) {
      ev.preventDefault();
      ev.stopPropagation();
    }
    this.player.audioOut.unlock(
      function () {
        if (this.unmuteButton) {
          this.unmuteButton.style.display = "none";
        }
        element.removeEventListener("touchstart", this.unlockAudioBound);
        element.removeEventListener("click", this.unlockAudioBound);
      }.bind(this)
    );
  };
  VideoElement.prototype.onClick = function (ev) {
    if (this.player.isPlaying) {
      this.player.pause();
      this.playButton.style.display = "block";
    } else {
      this.player.play();
      this.playButton.style.display = "none";
      if (this.poster) {
        this.poster.style.display = "none";
      }
    }
  };
  VideoElement.PLAY_BUTTON =
    '<svg style="max-width: 75px; max-height: 75px;" ' +
    'viewBox="0 0 200 200" alt="Play video">' +
    '<circle cx="100" cy="100" r="90" fill="none" ' +
    'stroke-width="15" stroke="#fff"/>' +
    '<polygon points="70, 55 70, 145 145, 100" fill="#fff"/>' +
    "</svg>";
  VideoElement.UNMUTE_BUTTON =
    '<svg style="max-width: 75px; max-height: 75px;" viewBox="0 0 75 75">' +
    '<polygon class="audio-speaker" stroke="none" fill="#fff" ' +
    'points="39,13 22,28 6,28 6,47 21,47 39,62 39,13"/>' +
    '<g stroke="#fff" stroke-width="5">' +
    '<path d="M 49,50 69,26"/>' +
    '<path d="M 69,50 49,26"/>' +
    "</g>" +
    "</svg>";
  return VideoElement;
})();
JSWebrtc.Player = (function () {
  "use strict";
  const Player = function (url, options) {
    this.options = options || {};
    if (!url.match(/^webrtc?:\/\//)) {
      throw "JSWebrtc just work with webrtc";
    }
    if (!this.options.video) {
      throw "VideoElement is null";
    }
    this.urlParams = JSWebrtc.ParseUrl(url);
    this.pc = null;
    this.autoplay = !!options.autoplay || false;
    this.paused = true;
    if (this.autoplay) this.options.video.muted = true;
    this.startLoading();
  };
  Player.prototype.startLoading = function () {
    const _self = this;
    if (_self.pc) {
      _self.pc.close();
    }
    _self.pc = new RTCPeerConnection(null);
    _self.pc.ontrack = function (event) {
      _self.options.video.srcObject = event.streams[0];
    };
    _self.pc.addTransceiver("video", { direction: "recvonly" });
    _self.pc
      .createOffer()
      .then(function (offer) {
        return _self.pc.setLocalDescription(offer).then(function () {
          return offer;
        });
      })
      .then(function (offer) {
        return new Promise(function (resolve, reject) {
          const port = _self.urlParams.port || 1985;
          let api = _self.urlParams.user_query.play || "/rtc/v1/play/";
          if (api.lastIndexOf("/") != api.length - 1) {
            api += "/";
          }
          let url = "http://" + _self.urlParams.server + ":" + port + api;
          for (const key in _self.urlParams.user_query) {
            if (key != "api" && key != "play") {
              url += "&" + key + "=" + _self.urlParams.user_query[key];
            }
          }
          const data = {
            api: url,
            streamurl: _self.urlParams.url,
            clientip: null,
            sdp: offer.sdp,
          };
          console.log("offer: ", data);
          JSWebrtc.HttpPost(url, JSON.stringify(data)).then(
            function (res) {
              console.log("answer: ", res);
              resolve(res.sdp);
            },
            function (rej) {
              reject(rej);
            }
          );
        });
      })
      .then(function (answer) {
        return _self.pc.setRemoteDescription(
          new RTCSessionDescription({ type: "answer", sdp: answer })
        );
      })
      .catch(function (reason) {
        throw reason;
      });
    if (this.autoplay) {
      this.play();
    }
  };
  Player.prototype.play = function (ev) {
    if (this.animationId) {
      return;
    }
    this.animationId = requestAnimationFrame(this.update.bind(this));
    this.paused = false;
  };
  Player.prototype.pause = function (ev) {
    if (this.paused) {
      return;
    }
    cancelAnimationFrame(this.animationId);
    this.animationId = null;
    this.isPlaying = false;
    this.paused = true;
    this.options.video.pause();
    if (this.options.onPause) {
      this.options.onPause(this);
    }
  };
  Player.prototype.stop = function (ev) {
    this.pause();
  };
  Player.prototype.destroy = function () {
    this.pause();
    this.pc && this.pc.close() && this.pc.destroy();
    this.audioOut && this.audioOut.destroy();
  };
  Player.prototype.update = function () {
    this.animationId = requestAnimationFrame(this.update.bind(this));
    if (this.options.video.readyState < 4) {
      return;
    }
    if (!this.isPlaying) {
      this.isPlaying = true;
      this.options.video.play();
      if (this.options.onPlay) {
        this.options.onPlay(this);
      }
    }
  };
  return Player;
})();
export default JSWebrtc;
```

3. **在 index.vue 文件中，书写以下代码：**

```vue
<template>
  <div class="webrtc-live">
    <video class="video-player" ref="VideoWebrtc" controls autoplay></video>
  </div>
</template>

<script>
import jswebrtc from "./utils/jswebrtc.js";
export default {
  name: "WebrtcLive",
  props: {
    liveStreamUrl: {
      type: String,
      default: null,
    },
  },
  data() {
    return {};
  },
  watch: {
    // 监听直播流地址
    liveStreamUrl: {
      handler(newVal, oldVal) {
        // 初始化加载直播流
        if (newVal && newVal !== oldVal) {
          this.$nextTick(() => {
            // 连接地址（开发环境地址 || 正式上线环境地址）
            let url;
            if (newVal.includes("http")) {
              url = newVal;
            } else {
              // 此处需要在 .env.development 文件中配置后端的 host 地址
              const host =
                process.env.VUE_APP_BACKEND_HOST || window.location.host;
              url = "http://" + host + newVal;
            }
            this.init(url);
          });
        }
      },
      immediate: true,
    },
  },
  methods: {
    init(url) {
      new jswebrtc.Player(url, {
        video: this.$refs.VideoWebrtc,
        autoplay: true,
        onPlay: () => {
          console.log("start play livestream");
        },
      });
    },
  },
};
</script>

<style lang="scss" scoped>
.webrtc-live {
  height: 100%;
  overflow: hidden;
  .video-player {
    width: 100%;
    height: 100%;
    object-fit: fill;
  }
}
</style>
```

4. **将其注册为全局组件，在需要的地方使用：**

```vue
<web-rtc-live v-else :live-stream-url="直播流地址" />
```



##### （三）whep 协议 RTC 直播流

1. **在 @/components 目录下新建 WhepRtcLive 文件夹，并在其中新建 utils 文件夹，和 index.vue 文件，utils 文件夹中新建 whepRTC.js 文件**
2. **在 whepRTC.js 文件中，书写以下代码：**

```javascript
export function SrsRtcWhipWhepAsync() {
  var self = {};

  self.constraints = {
    audio: true,
    video: {
      width: { ideal: 320, max: 576 },
    },
  };

  self.publish = async function (url, options) {
    if (url.indexOf("/whip/") === -1)
      throw new Error(`invalid WHIP url ${url}`);
    if (options?.videoOnly && options?.audioOnly)
      throw new Error(
        `The videoOnly and audioOnly in options can't be true at the same time`
      );

    if (!options?.videoOnly) {
      self.pc.addTransceiver("audio", { direction: "sendonly" });
    } else {
      self.constraints.audio = false;
    }

    if (!options?.audioOnly) {
      self.pc.addTransceiver("video", { direction: "sendonly" });
    } else {
      self.constraints.video = false;
    }

    if (
      !navigator.mediaDevices &&
      window.location.protocol === "http:" &&
      window.location.hostname !== "localhost"
    ) {
      throw new Error("加载失败");
    }
    var stream = await navigator.mediaDevices.getUserMedia(self.constraints);

    stream.getTracks().forEach(function (track) {
      self.pc.addTrack(track);

      // Notify about local track when stream is ok.
      self.ontrack && self.ontrack({ track: track });
    });

    var offer = await self.pc.createOffer();
    await self.pc.setLocalDescription(offer);
    const answer = await new Promise(function (resolve, reject) {
      console.log(`Generated offer: ${offer.sdp}`);

      const xhr = new XMLHttpRequest();
      xhr.onload = function () {
        if (xhr.readyState !== xhr.DONE) return;
        if (xhr.status !== 200 && xhr.status !== 201) return reject(xhr);
        const data = xhr.responseText;
        console.log("Got answer: ", data);
        return data.code ? reject(xhr) : resolve(data);
      };
      xhr.open("POST", url, true);
      xhr.setRequestHeader("Content-type", "application/sdp");
      xhr.send(offer.sdp);
    });
    await self.pc.setRemoteDescription(
      new RTCSessionDescription({ type: "answer", sdp: answer })
    );

    return self.__internal.parseId(url, offer.sdp, answer);
  };

  self.play = async function (url, options) {
    if (url.indexOf("/whip-play/") === -1 && url.indexOf("/whep/") === -1)
      throw new Error(`invalid WHEP url ${url}`);
    if (options?.videoOnly && options?.audioOnly)
      throw new Error(
        `The videoOnly and audioOnly in options can't be true at the same time`
      );

    if (!options?.videoOnly)
      self.pc.addTransceiver("audio", { direction: "recvonly" });
    if (!options?.audioOnly)
      self.pc.addTransceiver("video", { direction: "recvonly" });

    var offer = await self.pc.createOffer();
    await self.pc.setLocalDescription(offer);
    const answer = await new Promise(function (resolve, reject) {
      console.log(`Generated offer: ${offer.sdp}`);

      const xhr = new XMLHttpRequest();
      xhr.onload = function () {
        if (xhr.readyState !== xhr.DONE) return;
        if (xhr.status !== 200 && xhr.status !== 201) return reject(xhr);
        const data = xhr.responseText;
        console.log("Got answer: ", data);
        return data.code ? reject(xhr) : resolve(data);
      };
      xhr.open("POST", url, true);
      xhr.setRequestHeader("Content-type", "application/sdp");
      xhr.send(offer.sdp);
    });
    await self.pc.setRemoteDescription(
      new RTCSessionDescription({ type: "answer", sdp: answer })
    );

    return self.__internal.parseId(url, offer.sdp, answer);
  };

  // Close the publisher.
  self.close = function () {
    self.pc && self.pc.close();
    self.pc = null;
  };

  // The callback when got local stream.
  self.ontrack = function (event) {
    // Add track to stream of SDK.
    self.stream.addTrack(event.track);
  };

  self.pc = new RTCPeerConnection(null);

  // To keep api consistent between player and publisher.
  self.stream = new MediaStream();

  // Internal APIs.
  self.__internal = {
    parseId: (url, offer, answer) => {
      let sessionid = offer.substr(
        offer.indexOf("a=ice-ufrag:") + "a=ice-ufrag:".length
      );
      sessionid = sessionid.substr(0, sessionid.indexOf("\n") - 1) + ":";
      sessionid += answer.substr(
        answer.indexOf("a=ice-ufrag:") + "a=ice-ufrag:".length
      );
      sessionid = sessionid.substr(0, sessionid.indexOf("\n"));

      const a = document.createElement("a");
      a.href = url;
      return {
        sessionid: sessionid, // Should be ice-ufrag of answer:offer.
        simulator: a.protocol + "//" + a.host + "/rtc/v1/nack/",
      };
    },
  };

  self.pc.ontrack = function (event) {
    if (self.ontrack) {
      self.ontrack(event);
    }
  };

  return self;
}
```

3. **在 index.vue 文件中，书写以下代码：**

```vue
<template>
  <div class="whep-rtc-live">
    <video class="video-player" ref="VideoWebrtc" controls autoplay></video>
  </div>
</template>

<script>
import { SrsRtcWhipWhepAsync } from "./utils/whepRTC.js";
export default {
  name: "WhepRtcLive",
  props: {
    liveStreamUrl: {
      type: String,
      default: null,
    },
  },
  data() {
    return {};
  },
  watch: {
    // 监听直播流地址
    liveStreamUrl: {
      handler(newVal, oldVal) {
        // 初始化加载直播流
        if (newVal && newVal !== oldVal) {
          this.$nextTick(() => {
            // 连接地址（开发环境地址 || 正式上线环境地址）
            let url;
            if (newVal.includes("http")) {
              url = newVal;
            } else {
              // 此处需要在 .env.development 文件中配置后端的 host 地址
              const host =
                process.env.VUE_APP_BACKEND_HOST || window.location.host;
              url = "http://" + host + newVal;
            }
            this.init(url);
          });
        }
      },
      immediate: true,
    },
  },
  methods: {
    init(url) {
      if (this.sdk) {
        this.sdk.close();
      }
      this.sdk = new SrsRtcWhipWhepAsync();
      this.$refs.VideoWebrtc.srcObject = this.sdk.stream;
      this.sdk
        .play(url, {
          videoOnly: true,
          audioOnly: false,
        })
        .catch(function (reason) {
          this.sdk.close();
          console.log("错误原因：", reason);
        });
    },
  },
  beforeDestroy() {
    // 组件销毁前，销毁直播流
    if (this.sdk) {
      this.sdk.close();
    }
  },
};
</script>

<style lang="scss" scoped>
.whep-rtc-live {
  height: 100%;
  overflow: hidden;
  .video-player {
    width: 100%;
    height: 100%;
    object-fit: fill;
  }
}
</style>
```

4. **将其注册为全局组件，在需要的地方使用：**

```vue
<whep-rtc-live :live-stream-url="直播流地址" />
```



#### 五十二、SVG 组件，自动化进阶

1. **在 @/components 目录下新建 SvgIcon 文件夹，并在其中新建 icons 文件夹，和 SvgIcon.vue 文件，以及 index.js 文件**
2. **在 SvgIcon.vue 文件中，书写以下代码：**

```vue
<template>
  <div
    v-if="isExternal"
    :style="styleExternalIcon"
    class="svg-external-icon svg-icon"
    v-on="$listeners"
  />
  <svg v-else :class="svgClass" aria-hidden="true" v-on="$listeners">
    <use :xlink:href="iconName" />
  </svg>
</template>

<script>
export default {
  name: "SvgIcon",
  props: {
    icon: {
      type: String,
      required: true,
    },
    className: {
      type: String,
      default: "",
    },
  },
  computed: {
    // 是否为外部链接
    isExternal() {
      return /^(https?:|mailto:|tel:)/.test(this.icon);
    },
    // 基于传递过来的 icon 属性值，处理成 svg 能够识别的图标名称
    iconName() {
      return `#icon-${this.icon.trim()}`;
    },
    // 自定义类名
    svgClass() {
      if (this.className) {
        return "svg-icon " + this.className;
      } else {
        return "svg-icon";
      }
    },
    // 外部链接样式
    styleExternalIcon() {
      return {
        mask: `url(${this.icon}) no-repeat 50% 50%`,
        "-webkit-mask": `url(${this.icon}) no-repeat 50% 50%`,
      };
    },
  },
};
</script>

<style scoped lang="scss">
.svg-icon {
  width: 1em;
  height: 1em;
  vertical-align: -0.15em;
  fill: currentColor;
  overflow: hidden;
}

.svg-external-icon {
  background-color: currentColor;
  mask-size: cover !important;
  display: inline-block;
}
</style>
```

3. **在 index.js 文件中书写以下代码：**

```javascript
import Vue from "vue";
import SvgIcon from "@/components/SvgIcon/SvgIcon.vue";

// 全局注册 SvgIcon 组件
Vue.component("SvgIcon", SvgIcon);

// 此段代码用于自动导入指定目录下的所有 svg 文件
const req = require.context("./icons", false, /\.svg$/);
const requireAll = (requireContext) =>
  requireContext.keys().map(requireContext);
requireAll(req);
```

4. **在入口文件 main.js 中引入上述的 index.js 文件：import "@/components/SvgIcon";**
5. **下载 svg 精灵加载依赖包（会自动识别指定目录下的 svg 文件，转变为类似于 iconfont.js 文件的形式，可以直接被 SvgIcon 组件识别并使用）：yarn add svg-sprite-loader -D，并在 vue.config.js 中的 chainWebpack 中添加如下配置：**

```javascript
// 尤其注意：最外层需引入 path 方法
const path = require("path");

// 注意：需要在 chainWebpack 中添加
  chainWebpack(config) {
    // set svg-sprite-loader
    config.module
      .rule("svg")
      .exclude.add(path.join(__dirname, "src/components/SvgIcon/icons")) // icons 文件夹目录
      .end();
    config.module
      .rule("icons")
      .test(/\.svg$/)
      .include.add(path.join(__dirname, "src/components/SvgIcon/icons")) // icons 文件夹目录
      .end()
      .use("svg-sprite-loader")
      .loader("svg-sprite-loader")
      .options({
        symbolId: "icon-[name]",
      })
      .end();
  }
```

**解释：icons 文件夹中用于存放 svg 文件，每一个 svg 文件的名称可任意更改，且 svg 文件名称（强调：文件名称）就是 SvgIcon 组件需要传递的 icon 属性值**

6. **使用：`<svg-icon icon="svg文件名称" class-name="自定义类名（用于修改样式，如大小、颜色）" />`**

**注意：修改颜色要求 svg 文件，本身去除了颜色，可以通过上传到 iconfont 官网，通过去除颜色，再下载，添加到 icons 文件夹即可**



#### 五十三、解决浏览器中，图片缓存不更新的问题

**概念：当图片的 url 地址没有发生变化，但图片的内容发生了变化，浏览器不会主动刷新图片，从而导致显示旧的内容**

**核心思路：在图片的 url 地址后面，添加 ?Date.now() 即可**

```vue
<img :src="`${保存 url 地址的变量}?${Date.now()}`" />
```

**在核心思路基础上，加以完善，并封装成工具函数：**

```javascript
// 热更新图片转换，返回新的图片地址，解决浏览器因缓存导致图片内容显示不正确的问题
export const hotUpdateImg = (url) => {
  // 生成当前时间戳
  const timestamp = new Date().getTime();
  // 将时间戳添加到图片 url 中，并返回
  return url + "?timestamp=" + timestamp;
};
```



#### 五十四、动态修改伪元素的样式

**方案一：通过动态 style 设置自定义属性名（--自定义属性名称）和属性值，本质上就是设置行内样式变量，然后 style 标签中的伪元素可通过 var（--自定义属性名称）可访问到该值，如需动态改变该自定义属性值，只需控制动态 style 中属性值的变化即可**

```vue
<标签名 :style="{ '--自定义属性名': 属性值变量 }"></标签名>
```



**方案二：通过原生 js 操作给 DOM 元素的 style 行内样式设置自定义属性名（--自定义属性名称）和属性值，本质上就是设置行内样式变量，通过 `dom对象.style.setProperty ('--自定义变量', '值')` 进行设置，然后 style 标签中的伪元素可通过 var（--自定义属性名称）可访问到该值，如需动态改变该自定义属性值，只需通过 js 重新设置该 DOM 元素的 style 行内样式的自定义属性名和其对应的值即可**

**尤其注意：以上两种方案，都必须是在 style 属性中设置自定义属性名和属性值，方才可以在 style 标签中访问，而不是在 DOM 元素根级别设置自定义属性**

**尤其注意：此处以伪元素为例，比较典型，实际开发中，可以通过父传子，控制任意 css 的样式**



**方案三：在 css 类名中，直接给属性使用 v-bind ( vue 中的变量名 ) 即可**



#### 五十五、本地存储中的 token 变化，强制退出登录

**在 App 根组件中的 created 钩子函数中，书写以下代码：**

```javascript
  created() {
    // 监听本地存储中 token 的变化
    window.addEventListener("storage", () => {
      // TOKEN_KEY 是本地存储保存 token 的键名
      if (!localStorage.getItem("TOKEN_KEY")) {
        // 如果本地存储中的 token 不存在，也就是在本地存储中删除 token，清除 vuex 中的 token 数据，并跳转到登录页
        this.$store.commit("user/removeToken");
        // 跳转到登录页面
        this.$router.push("/login");
        // 提示消息
        this.$message.error("开发者已将对应token删除！");
      }
    });
  }
```



#### 五十六、全屏功能

1. **下载依赖：yarn add screenfull**
2. **新建全局组件，写入以下代码，并全局注册：**

```vue
<template>
// 组件库图标组件，根据 isFullscreen 判断显示放大图标或缩小图标
  <a-icon
    class="icon"
    :type="isFullscreen ? 'fullscreen-exit' : 'fullscreen'"
    @click="click"
  />
</template>

<script>
import screenfull from "screenfull";

export default {
  name: "ScreenFull",
  data() {
    return {
      isFullscreen: false,
    };
  },
  mounted() {
    this.init();
  },
  beforeDestroy() {
    this.destroy();
  },
  methods: {
    click() {
      if (!screenfull.isEnabled) {
        this.$message.error("浏览器不支持！");
        return false;
      }
      screenfull.toggle();
    },
    change() {
      this.isFullscreen = screenfull.isFullscreen;
    },
    init() {
      if (screenfull.isEnabled) {
        screenfull.on("change", this.change);
      }
    },
    destroy() {
      if (screenfull.isEnabled) {
        screenfull.off("change", this.change);
      }
    },
  },
};
</script>

<style lang="scss" scoped>
.icon {
  font-size: 30px;
}
</style>
```



#### 五十七、检验数据是否为有效数据

**需要检验的原因：如果是数组，检验是否为有效数据很方便，只需判断该数组是否存在并且长度是否大于 0 即可，但判断对象则比较麻烦，故作统一封装**

**注意：该工具函数由于经常会在 template 模板中使用，将其挂载到 vue 原型上更为便捷（原因：模块化导入该方法，无法在 template 模板上直接使用）**

```javascript
// 校验数据是否为有效数据（空对象或空数组返回 false，也可在 v-if 渲染模板时使用）
export const isValidValue = (value) => {
  if (Array.isArray(value)) {
    return value.length > 0;
  } else if (typeof value === "object" && value !== null) {
    return Object.keys(value).length > 0;
  }
  return Boolean(value);
};
```



#### 五十八、将在线 url 地址转换为 file 文件对象

**注意：该工具函数返回的是一个 Promise 对象，因此可以使用 await 进行接收**

```javascript
// 将在线 url 地址转换为 file 文件对象
export const getFileFromUrl = (url) => {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest()
        xhr.open('GET', url)
        xhr.setRequestHeader('Accept', 'image/png')
        xhr.responseType = 'blob'
        xhr.onload = () => {
            // 拿到二进制文件流
            const blob = xhr.response
            // 包装成 file 对象
            const file = new File([blob], `image_${new Date().getTime()}`, {type: 'image/png'})
            // 返回结果
            resolve(file)
        }
        xhr.onerror = e => {
            reject(e)
        }
        // 发送
        xhr.send()
    })
}
```



#### 五十九、Vue 中使用 WebSocket，并形成完整闭环

1. **新建 webSocket.js 文件，书写以下代码：**

```javascript
import qs from 'qs'
// uuid 唯一标识符
import { v4 as uuidv4 } from 'uuid'

// websocket 类
export default class ConnectWebSocket {
  // ws 实例
  ws = null
  // 是否应该重连 WebSocket（默认可以重连）
  isShouldReconnect = true
  // 心跳定时器
  heartbeatTimer = null
  // 重连定时器
  reconnectInterval = null
  // ws 请求地址
  url = null
  // ws 请求参数
  params = {}
  // 消息处理函数
  messageHandler = () => {}

  // 传入 url 地址和携带参数（不传默认为空对象）,消息处理函数
  constructor (url, params = {}, messageHandler) {
    // 保存外部传递的请求地址
    this.url = url
    // 保存外部传递的请求参数
    this.params = params
    // 保存外部传递的消息处理函数
    this.messageHandler = messageHandler
    // 初始化 socket
    this.initSocket()
  }

  // 初始化 socket
  initSocket () {
    // 每次建立连接前，先销毁上次连接，确保始终只有一个 Socket 处于连接状态
    if (this.ws && this.ws.readyState && this.ws.readyState !== WebSocket.CONNECTING) {
      // 向服务器发送断开请求
      this.ws && this.ws.send('end')
    }
    // 如果服务器没有进行关闭，确保手动进行关闭
    this.ws && this.ws.close()
    // 将 ws 实例清空
    this.ws = null
    // 用户凭据
    const token = 从 vuex 中获取
    // 连接地址（本地开发环境HOST || 正式上线环境HOST）
    const host = process.env.VUE_APP_BACKEND_HOST || window.location.host
    // 查询字符串所需要的参数（后续要将该对象转换为查询字符串格式）
    const query = {
      // token 凭证
      token,
      // uuid 唯一标识符
      uid: uuidv4(),
      // 额外携带参数
      ...this.params
    }
    // 建立连接
    this.ws = new WebSocket('ws://' + host + this.url + '?' + qs.stringify(query))

    // 连接成功时触发
    this.ws.onopen = () => {
      console.log('即将建立连接，当前连接 uid 为：', query.uid)
      console.log('WebSocket 已建立连接，开启心跳监测！')
      // 发送心跳检测消息
      this.sendHeartbeat()
      // 一旦连接上了，判断当前定时重连是否存在，如果存在，清除定时重连
      this.reconnectInterval && clearInterval(this.reconnectInterval)
    }

    // 接收到消息时触发
    this.ws.onmessage = (event) => {
      const res = JSON.parse(event.data)
      this.messageHandler && this.messageHandler(res)
    }

    // 连接断开时触发（没连接上也会触发）
    this.ws.onclose = () => {
      console.log('WebSocket 连接已断开，心跳监测已移除！')
      // 无论是意外断线，还是主动断线，都移除心跳监测
      this.heartbeatTimer && clearInterval(this.heartbeatTimer)
      // 如果当前为可重连状态
      if (this.isShouldReconnect) {
        console.log('此次 WebSocket 连接断开，为意外断开，正在主动重连！')
        // 断线重连
        this.reconnect()
      } else {
        console.log('此次 WebSocket 连接断开，为主动断开，不再重连！')
        // 判断当前定时重连是否存在，如果存在，清除定时重连
        this.reconnectInterval && clearInterval(this.reconnectInterval)
      }
    }

    // 错误监听
    this.ws.onerror = (event) => {
      if (event.type === 'error') {
        console.log('websocket 连接错误！', event)
      }
    }
  }

  // 发送心跳检测
  sendHeartbeat () {
    // 立即发送一次心跳监测
    if (this.ws && this.ws.readyState && this.ws.readyState === WebSocket.OPEN) {
      // 发送心跳消息到服务器
      this.ws.send('bip')
    }
    // 发送心跳检测消息（每五秒进行一次心跳检测）
    this.heartbeatTimer = setInterval(() => {
      if (this.ws && this.ws.readyState && this.ws.readyState === WebSocket.OPEN) {
        // 发送心跳消息到服务器
        this.ws.send('bip')
      }
    }, 5000)
  }

  // 断线重连
  reconnect () {
    // 每一次开启定时重连前，先清除之前的定时重连
    this.reconnectInterval && clearInterval(this.reconnectInterval)
    // 如果当前为连接关闭状态
    if (this.ws && this.ws.readyState === WebSocket.CLOSED) {
      // 每五秒进行一次重连
      this.reconnectInterval = setInterval(() => {
        // 如果服务器没有进行关闭，确保手动进行关闭
        this.ws && this.ws.close()
        // 将 ws 实例清空
        this.ws = null
        setTimeout(() => {
          this.initSocket()
        }, 1000)
      }, 5000)
    }
  }

  // 主动断开连接（销毁）
  destroy () {
    // 主动断开连接，将是否可以重连的状态设置为 false，在连接关闭后，阻止重连
    this.isShouldReconnect = false
    // 向服务器发送断开请求
    if (this.ws && this.ws.readyState && this.ws.readyState !== WebSocket.CONNECTING) {
      this.ws && this.ws.send('end')
    }
    // 如果服务器没有进行关闭，确保手动进行关闭
    this.ws && this.ws.close()
    // 将 ws 实例清空
    this.ws = null
  }

  // 发送消息
  send (data) {
    this.ws.send(data)
  }
}
```

2. **在需要使用 webSocket 的地方引入该工具类，并按照如下方式进行使用：**

```javascript
// 销毁 socket（1.页面销毁时调用; 2.多次创建链接时调用，最好每次建立链接前都先销毁一次）
// 解释：每次创建由于生成的是多个不同的实例，互相之间独立，因此新发起的 socket 并不会取消上一次发起的 socket，需要手动销毁
this.实例标识 && this.实例标识.destroy()

// 开启 ws 连接
this.实例标识 = new ConnectWebSocket(
  'ws链接地址',
  {
    // 需要携带的参数
  },
  (res) => {
    console.log('监听到消息：', res)
  }
)

// 发送 socket 消息
this.实例标识.send(需要发送的消息)
```


